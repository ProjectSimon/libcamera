<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcamera: libcamera::PipelineHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcamera
   &#160;<span id="projectnumber">v0.3.2+rpt20241101+6-22e19df9</span>
   </div>
   <div id="projectbrief">Supporting cameras in Linux since 2019</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcamera.html">libcamera</a></li><li class="navelem"><a class="el" href="classlibcamera_1_1PipelineHandler.html">PipelineHandler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlibcamera_1_1PipelineHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libcamera::PipelineHandler Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Create and manage cameras based on a set of media devices.  
 <a href="classlibcamera_1_1PipelineHandler.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for libcamera::PipelineHandler:</div>
<div class="dyncontent">
<div class="center"><img src="classlibcamera_1_1PipelineHandler__inherit__graph.png" border="0" usemap="#alibcamera_1_1PipelineHandler_inherit__map" alt="Inheritance graph"/></div>
<map name="alibcamera_1_1PipelineHandler_inherit__map" id="alibcamera_1_1PipelineHandler_inherit__map">
<area shape="rect" title="Create and manage cameras based on a set of media devices." alt="" coords="121,95,319,121"/>
<area shape="rect" title=" " alt="" coords="5,5,229,47"/>
<area shape="rect" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection." alt="" coords="254,13,391,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for libcamera::PipelineHandler:</div>
<div class="dyncontent">
<div class="center"><img src="classlibcamera_1_1PipelineHandler__coll__graph.png" border="0" usemap="#alibcamera_1_1PipelineHandler_coll__map" alt="Collaboration graph"/></div>
<map name="alibcamera_1_1PipelineHandler_coll__map" id="alibcamera_1_1PipelineHandler_coll__map">
<area shape="rect" title="Create and manage cameras based on a set of media devices." alt="" coords="925,71,1124,98"/>
<area shape="rect" title=" " alt="" coords="584,5,808,47"/>
<area shape="rect" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection." alt="" coords="254,79,391,106"/>
<area shape="rect" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system." alt="" coords="595,130,797,157"/>
<area shape="rect" href="classlibcamera_1_1Extensible.html" title="Base class to manage private data through a d&#45;pointer." alt="" coords="241,138,404,165"/>
<area shape="rect" title=" " alt="" coords="221,189,424,245"/>
<area shape="rect" title=" " alt="" coords="5,203,172,230"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3cea76fe8af047ed648bee391be7d268"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a3cea76fe8af047ed648bee391be7d268">PipelineHandler</a> (<a class="el" href="classlibcamera_1_1CameraManager.html">CameraManager</a> *manager)</td></tr>
<tr class="memdesc:a3cea76fe8af047ed648bee391be7d268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classlibcamera_1_1PipelineHandler.html" title="Create and manage cameras based on a set of media devices.">PipelineHandler</a> instance.  <a href="classlibcamera_1_1PipelineHandler.html#a3cea76fe8af047ed648bee391be7d268">More...</a><br /></td></tr>
<tr class="separator:a3cea76fe8af047ed648bee391be7d268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd5b652a2414b543ec20ba9dabf61b6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a7cd5b652a2414b543ec20ba9dabf61b6">match</a> (<a class="el" href="classlibcamera_1_1DeviceEnumerator.html">DeviceEnumerator</a> *enumerator)=0</td></tr>
<tr class="memdesc:a7cd5b652a2414b543ec20ba9dabf61b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match media devices and create camera instances.  <a href="classlibcamera_1_1PipelineHandler.html#a7cd5b652a2414b543ec20ba9dabf61b6">More...</a><br /></td></tr>
<tr class="separator:a7cd5b652a2414b543ec20ba9dabf61b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e424fe704e7b26094164b9189e0f84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcamera_1_1MediaDevice.html">MediaDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a77e424fe704e7b26094164b9189e0f84">acquireMediaDevice</a> (<a class="el" href="classlibcamera_1_1DeviceEnumerator.html">DeviceEnumerator</a> *enumerator, const <a class="el" href="classlibcamera_1_1DeviceMatch.html">DeviceMatch</a> &amp;dm)</td></tr>
<tr class="memdesc:a77e424fe704e7b26094164b9189e0f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search and acquire a <a class="el" href="classlibcamera_1_1MediaDevice.html" title="The MediaDevice represents a Media Controller device with its full graph of connected objects.">MediaDevice</a> matching a device pattern.  <a href="classlibcamera_1_1PipelineHandler.html#a77e424fe704e7b26094164b9189e0f84">More...</a><br /></td></tr>
<tr class="separator:a77e424fe704e7b26094164b9189e0f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ddfa7d422aefd4f99a382d6d711ffa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a57ddfa7d422aefd4f99a382d6d711ffa">acquire</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera)</td></tr>
<tr class="memdesc:a57ddfa7d422aefd4f99a382d6d711ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire exclusive access to the pipeline handler for the process.  <a href="classlibcamera_1_1PipelineHandler.html#a57ddfa7d422aefd4f99a382d6d711ffa">More...</a><br /></td></tr>
<tr class="separator:a57ddfa7d422aefd4f99a382d6d711ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead119b03920f468fa3bd091bfd65e5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#aead119b03920f468fa3bd091bfd65e5b">release</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera)</td></tr>
<tr class="memdesc:aead119b03920f468fa3bd091bfd65e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release exclusive access to the pipeline handler.  <a href="classlibcamera_1_1PipelineHandler.html#aead119b03920f468fa3bd091bfd65e5b">More...</a><br /></td></tr>
<tr class="separator:aead119b03920f468fa3bd091bfd65e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bbbe0826fb159253535ef077cb4343"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classlibcamera_1_1CameraConfiguration.html">CameraConfiguration</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a83bbbe0826fb159253535ef077cb4343">generateConfiguration</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera, Span&lt; const <a class="el" href="namespacelibcamera.html#a295d1f5e7828d95c0b0aabc0a8baac03">StreamRole</a> &gt; roles)=0</td></tr>
<tr class="memdesc:a83bbbe0826fb159253535ef077cb4343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a camera configuration for a specified camera.  <a href="classlibcamera_1_1PipelineHandler.html#a83bbbe0826fb159253535ef077cb4343">More...</a><br /></td></tr>
<tr class="separator:a83bbbe0826fb159253535ef077cb4343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930f2a9cdfb51dfb4b9ca3824e84fc29"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a930f2a9cdfb51dfb4b9ca3824e84fc29">configure</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera, <a class="el" href="classlibcamera_1_1CameraConfiguration.html">CameraConfiguration</a> *config)=0</td></tr>
<tr class="memdesc:a930f2a9cdfb51dfb4b9ca3824e84fc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a group of streams for capture.  <a href="classlibcamera_1_1PipelineHandler.html#a930f2a9cdfb51dfb4b9ca3824e84fc29">More...</a><br /></td></tr>
<tr class="separator:a930f2a9cdfb51dfb4b9ca3824e84fc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6312a69da7129c2ed41f9d9f790adf7c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a6312a69da7129c2ed41f9d9f790adf7c">exportFrameBuffers</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera, <a class="el" href="classlibcamera_1_1Stream.html">Stream</a> *stream, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classlibcamera_1_1FrameBuffer.html">FrameBuffer</a> &gt;&gt; *buffers)=0</td></tr>
<tr class="memdesc:a6312a69da7129c2ed41f9d9f790adf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and export buffers for <em>stream</em>.  <a href="classlibcamera_1_1PipelineHandler.html#a6312a69da7129c2ed41f9d9f790adf7c">More...</a><br /></td></tr>
<tr class="separator:a6312a69da7129c2ed41f9d9f790adf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e09cd47690f72b7c93483dc1372626"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a55e09cd47690f72b7c93483dc1372626">start</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera, const <a class="el" href="classlibcamera_1_1ControlList.html">ControlList</a> *controls)=0</td></tr>
<tr class="memdesc:a55e09cd47690f72b7c93483dc1372626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start capturing from a group of streams.  <a href="classlibcamera_1_1PipelineHandler.html#a55e09cd47690f72b7c93483dc1372626">More...</a><br /></td></tr>
<tr class="separator:a55e09cd47690f72b7c93483dc1372626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30b037abfb09bd548c53c9f9196a184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#ab30b037abfb09bd548c53c9f9196a184">stop</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera)</td></tr>
<tr class="memdesc:ab30b037abfb09bd548c53c9f9196a184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop capturing from all running streams and cancel pending requests.  <a href="classlibcamera_1_1PipelineHandler.html#ab30b037abfb09bd548c53c9f9196a184">More...</a><br /></td></tr>
<tr class="separator:ab30b037abfb09bd548c53c9f9196a184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac41ce2a1957534be1d1dd77145218e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#aac41ce2a1957534be1d1dd77145218e6">hasPendingRequests</a> (const <a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera) const</td></tr>
<tr class="memdesc:aac41ce2a1957534be1d1dd77145218e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the camera has any requests pending.  <a href="classlibcamera_1_1PipelineHandler.html#aac41ce2a1957534be1d1dd77145218e6">More...</a><br /></td></tr>
<tr class="separator:aac41ce2a1957534be1d1dd77145218e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca1e760238bd7cce8b78092333e2c6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a9ca1e760238bd7cce8b78092333e2c6a">registerRequest</a> (<a class="el" href="classlibcamera_1_1Request.html">Request</a> *request)</td></tr>
<tr class="memdesc:a9ca1e760238bd7cce8b78092333e2c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a request for use by the pipeline handler.  <a href="classlibcamera_1_1PipelineHandler.html#a9ca1e760238bd7cce8b78092333e2c6a">More...</a><br /></td></tr>
<tr class="separator:a9ca1e760238bd7cce8b78092333e2c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82dffe399ac974ecb375cbb2a2074dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#aa82dffe399ac974ecb375cbb2a2074dd">queueRequest</a> (<a class="el" href="classlibcamera_1_1Request.html">Request</a> *request)</td></tr>
<tr class="memdesc:aa82dffe399ac974ecb375cbb2a2074dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a request.  <a href="classlibcamera_1_1PipelineHandler.html#aa82dffe399ac974ecb375cbb2a2074dd">More...</a><br /></td></tr>
<tr class="separator:aa82dffe399ac974ecb375cbb2a2074dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad388abbf81afa644f366326dc41d7b63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#ad388abbf81afa644f366326dc41d7b63">completeBuffer</a> (<a class="el" href="classlibcamera_1_1Request.html">Request</a> *request, <a class="el" href="classlibcamera_1_1FrameBuffer.html">FrameBuffer</a> *buffer)</td></tr>
<tr class="memdesc:ad388abbf81afa644f366326dc41d7b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a buffer for a request.  <a href="classlibcamera_1_1PipelineHandler.html#ad388abbf81afa644f366326dc41d7b63">More...</a><br /></td></tr>
<tr class="separator:ad388abbf81afa644f366326dc41d7b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4184b62419a6e658c6a86438023519b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a4184b62419a6e658c6a86438023519b2">completeRequest</a> (<a class="el" href="classlibcamera_1_1Request.html">Request</a> *request)</td></tr>
<tr class="memdesc:a4184b62419a6e658c6a86438023519b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlibcamera_1_1Signal.html" title="Generic signal and slot communication mechanism.">Signal</a> request completion.  <a href="classlibcamera_1_1PipelineHandler.html#a4184b62419a6e658c6a86438023519b2">More...</a><br /></td></tr>
<tr class="separator:a4184b62419a6e658c6a86438023519b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d96ced1bc15f35c8c7065a312931e30"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a6d96ced1bc15f35c8c7065a312931e30">configurationFile</a> (const std::string &amp;subdir, const std::string &amp;<a class="el" href="classlibcamera_1_1PipelineHandler.html#a48262f4e8cc73803f0aeea8229330ee4">name</a>) const</td></tr>
<tr class="memdesc:a6d96ced1bc15f35c8c7065a312931e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the absolute path to a platform configuration file.  <a href="classlibcamera_1_1PipelineHandler.html#a6d96ced1bc15f35c8c7065a312931e30">More...</a><br /></td></tr>
<tr class="separator:a6d96ced1bc15f35c8c7065a312931e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48262f4e8cc73803f0aeea8229330ee4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a48262f4e8cc73803f0aeea8229330ee4">name</a> () const</td></tr>
<tr class="memdesc:a48262f4e8cc73803f0aeea8229330ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the pipeline handler name.  <a href="classlibcamera_1_1PipelineHandler.html#a48262f4e8cc73803f0aeea8229330ee4">More...</a><br /></td></tr>
<tr class="separator:a48262f4e8cc73803f0aeea8229330ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20b6e64ab88efefa436a06ffa1834c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcamera_1_1CameraManager.html">CameraManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#ac20b6e64ab88efefa436a06ffa1834c3">cameraManager</a> () const</td></tr>
<tr class="memdesc:ac20b6e64ab88efefa436a06ffa1834c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> that this pipeline handler belongs to.  <a href="classlibcamera_1_1PipelineHandler.html#ac20b6e64ab88efefa436a06ffa1834c3">More...</a><br /></td></tr>
<tr class="separator:ac20b6e64ab88efefa436a06ffa1834c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlibcamera_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlibcamera_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlibcamera_1_1Object.html">libcamera::Object</a></td></tr>
<tr class="memitem:a0425e0a986630b5881558378fad91687 inherit pub_methods_classlibcamera_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a0425e0a986630b5881558378fad91687">Object</a> (<a class="el" href="classlibcamera_1_1Object.html">Object</a> *<a class="el" href="classlibcamera_1_1Object.html#a469143548519e7ac9525e5b2b45e983f">parent</a>=nullptr)</td></tr>
<tr class="memdesc:a0425e0a986630b5881558378fad91687 inherit pub_methods_classlibcamera_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instance.  <a href="classlibcamera_1_1Object.html#a0425e0a986630b5881558378fad91687">More...</a><br /></td></tr>
<tr class="separator:a0425e0a986630b5881558378fad91687 inherit pub_methods_classlibcamera_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52c17ff4161b166ae71e766d0649b97 inherit pub_methods_classlibcamera_1_1Object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#ad52c17ff4161b166ae71e766d0649b97">~Object</a> ()</td></tr>
<tr class="memdesc:ad52c17ff4161b166ae71e766d0649b97 inherit pub_methods_classlibcamera_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instance.  <a href="classlibcamera_1_1Object.html#ad52c17ff4161b166ae71e766d0649b97">More...</a><br /></td></tr>
<tr class="separator:ad52c17ff4161b166ae71e766d0649b97 inherit pub_methods_classlibcamera_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7432a52a2e69a29cfe8144929686d1e6 inherit pub_methods_classlibcamera_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a7432a52a2e69a29cfe8144929686d1e6">deleteLater</a> ()</td></tr>
<tr class="memdesc:a7432a52a2e69a29cfe8144929686d1e6 inherit pub_methods_classlibcamera_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule deletion of the instance in the thread it belongs to.  <a href="classlibcamera_1_1Object.html#a7432a52a2e69a29cfe8144929686d1e6">More...</a><br /></td></tr>
<tr class="separator:a7432a52a2e69a29cfe8144929686d1e6 inherit pub_methods_classlibcamera_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ae92dfe5f3741c64ebdec61a2f5bef inherit pub_methods_classlibcamera_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#af9ae92dfe5f3741c64ebdec61a2f5bef">postMessage</a> (std::unique_ptr&lt; <a class="el" href="classlibcamera_1_1Message.html">Message</a> &gt; msg)</td></tr>
<tr class="memdesc:af9ae92dfe5f3741c64ebdec61a2f5bef inherit pub_methods_classlibcamera_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a message to the object's thread.  <a href="classlibcamera_1_1Object.html#af9ae92dfe5f3741c64ebdec61a2f5bef">More...</a><br /></td></tr>
<tr class="separator:af9ae92dfe5f3741c64ebdec61a2f5bef inherit pub_methods_classlibcamera_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4ea2209e289e2aabb75c5718d5b4a7 inherit pub_methods_classlibcamera_1_1Object"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename... FuncArgs, typename... Args, std::enable_if_t&lt; std::is_base_of&lt; Object, T &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2a4ea2209e289e2aabb75c5718d5b4a7 inherit pub_methods_classlibcamera_1_1Object"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a2a4ea2209e289e2aabb75c5718d5b4a7">invokeMethod</a> (R(T::*func)(FuncArgs...), <a class="el" href="namespacelibcamera.html#ae2c8412791b9597d590a7d0b2c9e2919">ConnectionType</a> type, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2a4ea2209e289e2aabb75c5718d5b4a7 inherit pub_methods_classlibcamera_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a method asynchronously on an <a class="el" href="classlibcamera_1_1Object.html" title="Base object to support automatic signal disconnection.">Object</a> instance.  <a href="classlibcamera_1_1Object.html#a2a4ea2209e289e2aabb75c5718d5b4a7">More...</a><br /></td></tr>
<tr class="separator:a2a4ea2209e289e2aabb75c5718d5b4a7 inherit pub_methods_classlibcamera_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca52b8790edc25af65d6fe937355577b inherit pub_methods_classlibcamera_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcamera_1_1Thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#aca52b8790edc25af65d6fe937355577b">thread</a> () const</td></tr>
<tr class="memdesc:aca52b8790edc25af65d6fe937355577b inherit pub_methods_classlibcamera_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the thread the object is bound to.  <a href="classlibcamera_1_1Object.html#aca52b8790edc25af65d6fe937355577b">More...</a><br /></td></tr>
<tr class="separator:aca52b8790edc25af65d6fe937355577b inherit pub_methods_classlibcamera_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8045a16ae8a093722466ca7129db6fc2 inherit pub_methods_classlibcamera_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a8045a16ae8a093722466ca7129db6fc2">moveToThread</a> (<a class="el" href="classlibcamera_1_1Thread.html">Thread</a> *<a class="el" href="classlibcamera_1_1Object.html#aca52b8790edc25af65d6fe937355577b">thread</a>)</td></tr>
<tr class="memdesc:a8045a16ae8a093722466ca7129db6fc2 inherit pub_methods_classlibcamera_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the object and all its children to a different thread.  <a href="classlibcamera_1_1Object.html#a8045a16ae8a093722466ca7129db6fc2">More...</a><br /></td></tr>
<tr class="separator:a8045a16ae8a093722466ca7129db6fc2 inherit pub_methods_classlibcamera_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469143548519e7ac9525e5b2b45e983f inherit pub_methods_classlibcamera_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcamera_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a469143548519e7ac9525e5b2b45e983f">parent</a> () const</td></tr>
<tr class="memdesc:a469143548519e7ac9525e5b2b45e983f inherit pub_methods_classlibcamera_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the object's parent.  <a href="classlibcamera_1_1Object.html#a469143548519e7ac9525e5b2b45e983f">More...</a><br /></td></tr>
<tr class="separator:a469143548519e7ac9525e5b2b45e983f inherit pub_methods_classlibcamera_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a97bc7a1ac8e7128d4b3dff91eb03f2a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a97bc7a1ac8e7128d4b3dff91eb03f2a4">registerCamera</a> (std::shared_ptr&lt; <a class="el" href="classlibcamera_1_1Camera.html">Camera</a> &gt; camera)</td></tr>
<tr class="memdesc:a97bc7a1ac8e7128d4b3dff91eb03f2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a camera to the camera manager and pipeline handler.  <a href="classlibcamera_1_1PipelineHandler.html#a97bc7a1ac8e7128d4b3dff91eb03f2a4">More...</a><br /></td></tr>
<tr class="separator:a97bc7a1ac8e7128d4b3dff91eb03f2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b18b2f7a20e726485880cae509204d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a25b18b2f7a20e726485880cae509204d">hotplugMediaDevice</a> (<a class="el" href="classlibcamera_1_1MediaDevice.html">MediaDevice</a> *media)</td></tr>
<tr class="memdesc:a25b18b2f7a20e726485880cae509204d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable hotplug handling for a media device.  <a href="classlibcamera_1_1PipelineHandler.html#a25b18b2f7a20e726485880cae509204d">More...</a><br /></td></tr>
<tr class="separator:a25b18b2f7a20e726485880cae509204d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106914cca210640c9da9ee1f0419e83c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a106914cca210640c9da9ee1f0419e83c">queueRequestDevice</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera, <a class="el" href="classlibcamera_1_1Request.html">Request</a> *request)=0</td></tr>
<tr class="memdesc:a106914cca210640c9da9ee1f0419e83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a request to the device.  <a href="classlibcamera_1_1PipelineHandler.html#a106914cca210640c9da9ee1f0419e83c">More...</a><br /></td></tr>
<tr class="separator:a106914cca210640c9da9ee1f0419e83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3080cc9159e9b31d4ea2376903b94efd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a3080cc9159e9b31d4ea2376903b94efd">stopDevice</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera)=0</td></tr>
<tr class="memdesc:a3080cc9159e9b31d4ea2376903b94efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop capturing from all running streams.  <a href="classlibcamera_1_1PipelineHandler.html#a3080cc9159e9b31d4ea2376903b94efd">More...</a><br /></td></tr>
<tr class="separator:a3080cc9159e9b31d4ea2376903b94efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7d619636c8988aeed3afd43ce8ed02"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a6f7d619636c8988aeed3afd43ce8ed02">acquireDevice</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera)</td></tr>
<tr class="memdesc:a6f7d619636c8988aeed3afd43ce8ed02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire resources associated with this camera.  <a href="classlibcamera_1_1PipelineHandler.html#a6f7d619636c8988aeed3afd43ce8ed02">More...</a><br /></td></tr>
<tr class="separator:a6f7d619636c8988aeed3afd43ce8ed02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f4bee6b4c1f4b071b5e2f7584a93f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#a53f4bee6b4c1f4b071b5e2f7584a93f8">releaseDevice</a> (<a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *camera)</td></tr>
<tr class="memdesc:a53f4bee6b4c1f4b071b5e2f7584a93f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release resources associated with this camera.  <a href="classlibcamera_1_1PipelineHandler.html#a53f4bee6b4c1f4b071b5e2f7584a93f8">More...</a><br /></td></tr>
<tr class="separator:a53f4bee6b4c1f4b071b5e2f7584a93f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classlibcamera_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classlibcamera_1_1Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classlibcamera_1_1Object.html">libcamera::Object</a></td></tr>
<tr class="memitem:a5328cab1412743716aa2748eeded8e80 inherit pro_methods_classlibcamera_1_1Object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a5328cab1412743716aa2748eeded8e80">message</a> (<a class="el" href="classlibcamera_1_1Message.html">Message</a> *msg)</td></tr>
<tr class="memdesc:a5328cab1412743716aa2748eeded8e80 inherit pro_methods_classlibcamera_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlibcamera_1_1Message.html" title="A message that can be posted to a Thread.">Message</a> handler for the object.  <a href="classlibcamera_1_1Object.html#a5328cab1412743716aa2748eeded8e80">More...</a><br /></td></tr>
<tr class="separator:a5328cab1412743716aa2748eeded8e80 inherit pro_methods_classlibcamera_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e81f2a2524dbe12daed49597cf66a57 inherit pro_methods_classlibcamera_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1Object.html#a6e81f2a2524dbe12daed49597cf66a57">assertThreadBound</a> (const char *<a class="el" href="classlibcamera_1_1Object.html#a5328cab1412743716aa2748eeded8e80">message</a>)</td></tr>
<tr class="memdesc:a6e81f2a2524dbe12daed49597cf66a57 inherit pro_methods_classlibcamera_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the caller complies with thread-bound constraints.  <a href="classlibcamera_1_1Object.html#a6e81f2a2524dbe12daed49597cf66a57">More...</a><br /></td></tr>
<tr class="separator:a6e81f2a2524dbe12daed49597cf66a57 inherit pro_methods_classlibcamera_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae78c43450c383e9bb8757cf01c70dc4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibcamera_1_1CameraManager.html">CameraManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1PipelineHandler.html#ae78c43450c383e9bb8757cf01c70dc4e">manager_</a></td></tr>
<tr class="memdesc:ae78c43450c383e9bb8757cf01c70dc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> manager associated with the pipeline handler.  <a href="classlibcamera_1_1PipelineHandler.html#ae78c43450c383e9bb8757cf01c70dc4e">More...</a><br /></td></tr>
<tr class="separator:ae78c43450c383e9bb8757cf01c70dc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af245a3786a3655857fb58eddd423dfdd"><td class="memItemLeft" align="right" valign="top"><a id="af245a3786a3655857fb58eddd423dfdd"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PipelineHandlerFactoryBase</b></td></tr>
<tr class="separator:af245a3786a3655857fb58eddd423dfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Create and manage cameras based on a set of media devices. </p>
<p>The <a class="el" href="classlibcamera_1_1PipelineHandler.html" title="Create and manage cameras based on a set of media devices.">PipelineHandler</a> matches the media devices provided by a <a class="el" href="classlibcamera_1_1DeviceEnumerator.html" title="Enumerate, store and search media devices.">DeviceEnumerator</a> with the pipelines it supports and creates corresponding <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> devices.</p>
<p>Pipeline handler instances are reference-counted through std::shared_ptr&lt;&gt;. They implement std::enable_shared_from_this&lt;&gt; in order to create new std::shared_ptr&lt;&gt; in code paths originating from member functions of the <a class="el" href="classlibcamera_1_1PipelineHandler.html" title="Create and manage cameras based on a set of media devices.">PipelineHandler</a> class where only the 'this' pointer is available. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3cea76fe8af047ed648bee391be7d268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cea76fe8af047ed648bee391be7d268">&#9670;&nbsp;</a></span>PipelineHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::PipelineHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1CameraManager.html">CameraManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classlibcamera_1_1PipelineHandler.html" title="Create and manage cameras based on a set of media devices.">PipelineHandler</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">manager</td><td>The camera manager</td></tr>
  </table>
  </dd>
</dl>
<p>In order to honour the std::enable_shared_from_this&lt;&gt; contract, <a class="el" href="classlibcamera_1_1PipelineHandler.html" title="Create and manage cameras based on a set of media devices.">PipelineHandler</a> instances shall never be constructed manually, but always through the <a class="el" href="classlibcamera_1_1PipelineHandlerFactoryBase.html#ada3bc5859a7dc78b30683da70ec707ca" title="Create an instance of the PipelineHandler corresponding to the factory.">PipelineHandlerFactoryBase::create()</a> function. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a57ddfa7d422aefd4f99a382d6d711ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ddfa7d422aefd4f99a382d6d711ffa">&#9670;&nbsp;</a></span>acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libcamera::PipelineHandler::acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire exclusive access to the pipeline handler for the process. </p>
<p>This function locks all the media devices used by the pipeline to ensure that no other process can access them concurrently.</p>
<p>Access to a pipeline handler may be acquired recursively from within the same process. Every successful <a class="el" href="classlibcamera_1_1PipelineHandler.html#a57ddfa7d422aefd4f99a382d6d711ffa" title="Acquire exclusive access to the pipeline handler for the process.">acquire()</a> call shall be matched with a <a class="el" href="classlibcamera_1_1PipelineHandler.html#aead119b03920f468fa3bd091bfd65e5b" title="Release exclusive access to the pipeline handler.">release()</a> call. This allows concurrent access to the same pipeline handler from different cameras within the same process.</p>
<p>Pipeline handlers shall not call this function directly as the <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> class handles access internally.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000045">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the pipeline handler was acquired, false if another process has already acquired it </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibcamera_1_1PipelineHandler.html#aead119b03920f468fa3bd091bfd65e5b" title="Release exclusive access to the pipeline handler.">release()</a> </dd></dl>

</div>
</div>
<a id="a6f7d619636c8988aeed3afd43ce8ed02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7d619636c8988aeed3afd43ce8ed02">&#9670;&nbsp;</a></span>acquireDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libcamera::PipelineHandler::acquireDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire resources associated with this camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera for which to acquire resources</td></tr>
  </table>
  </dd>
</dl>
<p>Pipeline handlers may override this in order to get resources such as opening devices and allocating buffers when a camera is acquired.</p>
<p>This is used by the uvcvideo pipeline handler to delay opening /dev/video# until the camera is acquired to avoid excess power consumption. The delayed opening of /dev/video# is a special case because the kernel uvcvideo driver powers on the USB device as soon as /dev/video# is opened. This behavior should <em>not</em> be copied by other pipeline handlers.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000047">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibcamera_1_1PipelineHandler.html#a53f4bee6b4c1f4b071b5e2f7584a93f8" title="Release resources associated with this camera.">releaseDevice()</a> </dd></dl>

</div>
</div>
<a id="a77e424fe704e7b26094164b9189e0f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e424fe704e7b26094164b9189e0f84">&#9670;&nbsp;</a></span>acquireMediaDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibcamera_1_1MediaDevice.html">MediaDevice</a> * libcamera::PipelineHandler::acquireMediaDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1DeviceEnumerator.html">DeviceEnumerator</a> *&#160;</td>
          <td class="paramname"><em>enumerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibcamera_1_1DeviceMatch.html">DeviceMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>dm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search and acquire a <a class="el" href="classlibcamera_1_1MediaDevice.html" title="The MediaDevice represents a Media Controller device with its full graph of connected objects.">MediaDevice</a> matching a device pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enumerator</td><td>Enumerator containing all media devices in the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dm</td><td>Device match pattern</td></tr>
  </table>
  </dd>
</dl>
<p>Search the device <em>enumerator</em> for an available media device matching the device match pattern <em>dm</em>. Matching media device that have previously been acquired by <a class="el" href="classlibcamera_1_1MediaDevice.html#a02fd5f5a3d81330a87f1ee53511866ef" title="Claim a device for exclusive use.">MediaDevice::acquire()</a> are not considered. If a match is found, the media device is acquired and returned. The caller shall not release the device explicitly, it will be automatically released when the pipeline handler is destroyed.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000044">Thread Safety:</a></b></dt><dd>This function shall be called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matching <a class="el" href="classlibcamera_1_1MediaDevice.html" title="The MediaDevice represents a Media Controller device with its full graph of connected objects.">MediaDevice</a>, or nullptr if no match is found </dd></dl>

</div>
</div>
<a id="ac20b6e64ab88efefa436a06ffa1834c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20b6e64ab88efefa436a06ffa1834c3">&#9670;&nbsp;</a></span>cameraManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::cameraManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> that this pipeline handler belongs to. </p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000060">Thread Safety:</a></b></dt><dd>This function is <a class="el" href="thread-safety.html#thread-safe">thread-safe</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> for this pipeline handler </dd></dl>

</div>
</div>
<a id="ad388abbf81afa644f366326dc41d7b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad388abbf81afa644f366326dc41d7b63">&#9670;&nbsp;</a></span>completeBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libcamera::PipelineHandler::completeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Request.html">Request</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1FrameBuffer.html">FrameBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete a buffer for a request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The request the buffer belongs to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer that has completed</td></tr>
  </table>
  </dd>
</dl>
<p>This function shall be called by pipeline handlers to signal completion of the <em>buffer</em> part of the <em>request</em>. It notifies applications of buffer completion and updates the request's internal buffer tracking. The request is not completed automatically when the last buffer completes to give pipeline handlers a chance to perform any operation that may still be needed. They shall complete requests explicitly with <a class="el" href="classlibcamera_1_1PipelineHandler.html#a4184b62419a6e658c6a86438023519b2" title="Signal request completion.">completeRequest()</a>.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000056">Thread Safety:</a></b></dt><dd>This function shall be called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if all buffers contained in the request have completed, false otherwise </dd></dl>

</div>
</div>
<a id="a4184b62419a6e658c6a86438023519b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4184b62419a6e658c6a86438023519b2">&#9670;&nbsp;</a></span>completeRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::PipelineHandler::completeRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Request.html">Request</a> *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classlibcamera_1_1Signal.html" title="Generic signal and slot communication mechanism.">Signal</a> request completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The request that has completed</td></tr>
  </table>
  </dd>
</dl>
<p>The pipeline handler shall call this function to notify the <em>camera</em> that the request has completed. The request is no longer managed by the pipeline handler and shall not be accessed once this function returns.</p>
<p>This function ensures that requests will be returned to the application in submission order, the pipeline handler may call it on any complete request without any ordering constraint.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000057">Thread Safety:</a></b></dt><dd>This function shall be called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread. </dd></dl>

</div>
</div>
<a id="a6d96ced1bc15f35c8c7065a312931e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d96ced1bc15f35c8c7065a312931e30">&#9670;&nbsp;</a></span>configurationFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string libcamera::PipelineHandler::configurationFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the absolute path to a platform configuration file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subdir</td><td>The pipeline handler specific subdirectory name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The configuration file name</td></tr>
  </table>
  </dd>
</dl>
<p>This function locates a named platform configuration file and returns its absolute path to the pipeline handler. It searches the following directories, in order:</p>
<ul>
<li>If libcamera is not installed, the src/libcamera/pipeline/&lt;subdir&gt;/data/ directory within the source tree ; otherwise</li>
<li>The system data (share/libcamera/pipeline/&lt;subdir&gt;) directory.</li>
</ul>
<p>The system directories are not searched if libcamera is not installed.</p>
<dl class="section return"><dt>Returns</dt><dd>The full path to the pipeline handler configuration file, or an empty string if no configuration file can be found </dd></dl>

</div>
</div>
<a id="a930f2a9cdfb51dfb4b9ca3824e84fc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930f2a9cdfb51dfb4b9ca3824e84fc29">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1CameraConfiguration.html">CameraConfiguration</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure a group of streams for capture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The camera configurations to setup</td></tr>
  </table>
  </dd>
</dl>
<p>Configure the specified group of streams for <em>camera</em> according to the configuration specified in <em>config</em>. The intended caller of this interface is the <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> class which will receive configuration to apply from the application.</p>
<p>The configuration is guaranteed to have been validated with <a class="el" href="classlibcamera_1_1CameraConfiguration.html#a29f8f263384c6149775b6011c7397093" title="Validate and possibly adjust the camera configuration.">CameraConfiguration::validate()</a>. The pipeline handler implementation shall not perform further validation and may rely on any custom field stored in its custom <a class="el" href="classlibcamera_1_1CameraConfiguration.html" title="Hold configuration for streams of the camera.">CameraConfiguration</a> derived class.</p>
<p>When configuring the camera the pipeline handler shall associate a <a class="el" href="classlibcamera_1_1Stream.html" title="Video stream for a camera.">Stream</a> instance to each <a class="el" href="structlibcamera_1_1StreamConfiguration.html" title="Configuration parameters for a stream.">StreamConfiguration</a> entry in the <a class="el" href="classlibcamera_1_1CameraConfiguration.html" title="Hold configuration for streams of the camera.">CameraConfiguration</a> using the <a class="el" href="structlibcamera_1_1StreamConfiguration.html#a74a0eb44dad1b00112c7c0443ae54a12" title="Associate a stream with a configuration.">StreamConfiguration::setStream()</a> function.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000050">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative error code otherwise </dd></dl>

</div>
</div>
<a id="a6312a69da7129c2ed41f9d9f790adf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6312a69da7129c2ed41f9d9f790adf7c">&#9670;&nbsp;</a></span>exportFrameBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::exportFrameBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Stream.html">Stream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classlibcamera_1_1FrameBuffer.html">FrameBuffer</a> &gt;&gt; *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and export buffers for <em>stream</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream to allocate buffers for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Array of buffers successfully allocated</td></tr>
  </table>
  </dd>
</dl>
<p>This function allocates buffers for the <em>stream</em> from the devices associated with the stream in the corresponding pipeline handler. Those buffers shall be suitable to be added to a <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request.">Request</a> for the stream, and shall be mappable to the CPU through their associated dmabufs with mmap().</p>
<p>The function may only be called after the <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> has been configured and before it gets started, or after it gets stopped. It shall be called only for streams that are part of the active camera configuration.</p>
<p>The only intended caller is Camera::exportFrameBuffers().</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000051">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of allocated buffers on success or a negative error code otherwise </dd></dl>

</div>
</div>
<a id="a83bbbe0826fb159253535ef077cb4343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83bbbe0826fb159253535ef077cb4343">&#9670;&nbsp;</a></span>generateConfiguration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::generateConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; const <a class="el" href="namespacelibcamera.html#a295d1f5e7828d95c0b0aabc0a8baac03">StreamRole</a> &gt;&#160;</td>
          <td class="paramname"><em>roles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a camera configuration for a specified camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera to generate a default configuration for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roles</td><td>A list of stream roles</td></tr>
  </table>
  </dd>
</dl>
<p>Generate a default configuration for the <em>camera</em> for a specified list of stream roles. The caller shall populate the <em>roles</em> with the use-cases it wishes to fetch the default configuration for. The returned configuration can then be examined by the caller to learn about the selected streams and their default parameters.</p>
<p>The intended companion to this is <em><a class="el" href="classlibcamera_1_1PipelineHandler.html#a930f2a9cdfb51dfb4b9ca3824e84fc29" title="Configure a group of streams for capture.">configure()</a></em> which can be used to change the group of streams parameters.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000049">Thread Safety:</a></b></dt><dd>This function may be called from any thread and shall be <a class="el" href="thread-safety.html#thread-safe">thread-safe</a>. It shall not modify the state of the <em>camera</em> in the pipeline handler.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="classlibcamera_1_1CameraConfiguration.html" title="Hold configuration for streams of the camera.">CameraConfiguration</a> if the requested roles can be satisfied, or a null pointer otherwise. </dd></dl>

</div>
</div>
<a id="aac41ce2a1957534be1d1dd77145218e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac41ce2a1957534be1d1dd77145218e6">&#9670;&nbsp;</a></span>hasPendingRequests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libcamera::PipelineHandler::hasPendingRequests </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the camera has any requests pending. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera to check</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines if there are any requests queued to the pipeline awaiting processing.</p>
<dl class="section return"><dt>Returns</dt><dd>True if there are pending requests, or false otherwise </dd></dl>

</div>
</div>
<a id="a25b18b2f7a20e726485880cae509204d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b18b2f7a20e726485880cae509204d">&#9670;&nbsp;</a></span>hotplugMediaDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::PipelineHandler::hotplugMediaDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1MediaDevice.html">MediaDevice</a> *&#160;</td>
          <td class="paramname"><em>media</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable hotplug handling for a media device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">media</td><td>The media device</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables hotplug handling, and especially hot-unplug handling, of the <em>media</em> device. It shall be called by pipeline handlers for all the media devices that can be disconnected.</p>
<p>When a media device passed to this function is later unplugged, the pipeline handler gets notified and automatically disconnects all the cameras it has registered without requiring any manual intervention. </p>

</div>
</div>
<a id="a7cd5b652a2414b543ec20ba9dabf61b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd5b652a2414b543ec20ba9dabf61b6">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1DeviceEnumerator.html">DeviceEnumerator</a> *&#160;</td>
          <td class="paramname"><em>enumerator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match media devices and create camera instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enumerator</td><td>The enumerator providing all media devices found in the system</td></tr>
  </table>
  </dd>
</dl>
<p>This function is the main entry point of the pipeline handler. It is called by the camera manager with the <em>enumerator</em> passed as an argument. It shall acquire from the <em>enumerator</em> all the media devices it needs for a single pipeline, create one or multiple <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> instances and register them with the camera manager.</p>
<p>If all media devices needed by the pipeline handler are found, they must all be acquired by a call to <a class="el" href="classlibcamera_1_1MediaDevice.html#a02fd5f5a3d81330a87f1ee53511866ef" title="Claim a device for exclusive use.">MediaDevice::acquire()</a>. This function shall then create the corresponding <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> instances, store them internally, and return true. Otherwise it shall not acquire any media device (or shall release all the media devices is has acquired by calling <a class="el" href="classlibcamera_1_1MediaDevice.html#a511ae507d3fffc097e938a7f55eb801c" title="Release a device previously claimed for exclusive use.">MediaDevice::release()</a>) and return false.</p>
<p>If multiple instances of a pipeline are available in the system, the <a class="el" href="classlibcamera_1_1PipelineHandler.html" title="Create and manage cameras based on a set of media devices.">PipelineHandler</a> class will be instantiated once per instance, and its <a class="el" href="classlibcamera_1_1PipelineHandler.html#a7cd5b652a2414b543ec20ba9dabf61b6" title="Match media devices and create camera instances.">match()</a> function called for every instance. Each call shall acquire media devices for one pipeline instance, until all compatible media devices are exhausted.</p>
<p>If this function returns true, a new instance of the pipeline handler will be created and its <a class="el" href="classlibcamera_1_1PipelineHandler.html#a7cd5b652a2414b543ec20ba9dabf61b6" title="Match media devices and create camera instances.">match()</a> function called.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000043">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if media devices have been acquired and camera instances created, or false otherwise </dd></dl>

</div>
</div>
<a id="a48262f4e8cc73803f0aeea8229330ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48262f4e8cc73803f0aeea8229330ee4">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the pipeline handler name. </p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000059">Thread Safety:</a></b></dt><dd>This function shall be <a class="el" href="thread-safety.html#thread-safe">thread-safe</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pipeline handler name </dd></dl>

</div>
</div>
<a id="aa82dffe399ac974ecb375cbb2a2074dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82dffe399ac974ecb375cbb2a2074dd">&#9670;&nbsp;</a></span>queueRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::PipelineHandler::queueRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Request.html">Request</a> *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue a request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The request to queue</td></tr>
  </table>
  </dd>
</dl>
<p>This function queues a capture request to the pipeline handler for processing. The request is first added to the internal list of waiting requests which have to be prepared to make sure they are ready for being queued to the pipeline handler.</p>
<p>The queue of waiting requests is iterated and all prepared requests are passed to the pipeline handler in the same order they have been queued by calling this function.</p>
<p>If a <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request.">Request</a> fails during the preparation phase or if the pipeline handler fails in queuing the request to the hardware the request is cancelled.</p>
<p>Keeping track of queued requests ensures automatic completion of all requests when the pipeline handler is stopped with <a class="el" href="classlibcamera_1_1PipelineHandler.html#ab30b037abfb09bd548c53c9f9196a184" title="Stop capturing from all running streams and cancel pending requests.">stop()</a>. <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request.">Request</a> completion shall be signalled by the pipeline handler using the <a class="el" href="classlibcamera_1_1PipelineHandler.html#a4184b62419a6e658c6a86438023519b2" title="Signal request completion.">completeRequest()</a> function.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000054">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread. </dd></dl>

</div>
</div>
<a id="a106914cca210640c9da9ee1f0419e83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106914cca210640c9da9ee1f0419e83c">&#9670;&nbsp;</a></span>queueRequestDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::queueRequestDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Request.html">Request</a> *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue a request to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera to queue the request to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The request to queue</td></tr>
  </table>
  </dd>
</dl>
<p>This function queues a capture request to the device for processing. The request contains a set of buffers associated with streams and a set of parameters. The pipeline handler shall program the device to ensure that the parameters will be applied to the frames captured in the buffers provided in the request.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000055">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative error code otherwise </dd></dl>

</div>
</div>
<a id="a97bc7a1ac8e7128d4b3dff91eb03f2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bc7a1ac8e7128d4b3dff91eb03f2a4">&#9670;&nbsp;</a></span>registerCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::PipelineHandler::registerCamera </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classlibcamera_1_1Camera.html">Camera</a> &gt;&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a camera to the camera manager and pipeline handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera to be added</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called by pipeline handlers to register the cameras they handle with the camera manager.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000058">Thread Safety:</a></b></dt><dd>This function shall be called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread. </dd></dl>

</div>
</div>
<a id="a9ca1e760238bd7cce8b78092333e2c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca1e760238bd7cce8b78092333e2c6a">&#9670;&nbsp;</a></span>registerRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::PipelineHandler::registerRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Request.html">Request</a> *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a request for use by the pipeline handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The request to register</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called when the request is created, and allows the pipeline handler to perform any one-time initialization it requries for the request. </p>

</div>
</div>
<a id="aead119b03920f468fa3bd091bfd65e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead119b03920f468fa3bd091bfd65e5b">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::PipelineHandler::release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release exclusive access to the pipeline handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera for which to release data</td></tr>
  </table>
  </dd>
</dl>
<p>This function releases access to the pipeline handler previously acquired by a call to <a class="el" href="classlibcamera_1_1PipelineHandler.html#a57ddfa7d422aefd4f99a382d6d711ffa" title="Acquire exclusive access to the pipeline handler for the process.">acquire()</a>. Every <a class="el" href="classlibcamera_1_1PipelineHandler.html#aead119b03920f468fa3bd091bfd65e5b" title="Release exclusive access to the pipeline handler.">release()</a> call shall match a previous successful <a class="el" href="classlibcamera_1_1PipelineHandler.html#a57ddfa7d422aefd4f99a382d6d711ffa" title="Acquire exclusive access to the pipeline handler for the process.">acquire()</a> call. Calling this function on a pipeline handler that hasn't been acquired results in undefined behaviour.</p>
<p>Pipeline handlers shall not call this function directly as the <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> class handles access internally.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000046">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibcamera_1_1PipelineHandler.html#a57ddfa7d422aefd4f99a382d6d711ffa" title="Acquire exclusive access to the pipeline handler for the process.">acquire()</a> </dd></dl>

</div>
</div>
<a id="a53f4bee6b4c1f4b071b5e2f7584a93f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f4bee6b4c1f4b071b5e2f7584a93f8">&#9670;&nbsp;</a></span>releaseDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::PipelineHandler::releaseDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release resources associated with this camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera for which to release resources</td></tr>
  </table>
  </dd>
</dl>
<p>Pipeline handlers may override this in order to perform cleanup operations when a camera is released, such as freeing memory.</p>
<p>This is called once for every camera that is released. If there are resources shared by multiple cameras then the pipeline handler must take care to not release them until <a class="el" href="classlibcamera_1_1PipelineHandler.html#a53f4bee6b4c1f4b071b5e2f7584a93f8" title="Release resources associated with this camera.">releaseDevice()</a> has been called for all previously acquired cameras.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000048">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibcamera_1_1PipelineHandler.html#a6f7d619636c8988aeed3afd43ce8ed02" title="Acquire resources associated with this camera.">acquireDevice()</a> </dd></dl>

</div>
</div>
<a id="a55e09cd47690f72b7c93483dc1372626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e09cd47690f72b7c93483dc1372626">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibcamera_1_1ControlList.html">ControlList</a> *&#160;</td>
          <td class="paramname"><em>controls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start capturing from a group of streams. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera to start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controls</td><td>Controls to be applied before starting the <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a></td></tr>
  </table>
  </dd>
</dl>
<p>Start the group of streams that have been configured for capture by <em><a class="el" href="classlibcamera_1_1PipelineHandler.html#a930f2a9cdfb51dfb4b9ca3824e84fc29" title="Configure a group of streams for capture.">configure()</a></em>. The intended caller of this function is the <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> class which will in turn be called from the application to indicate that it has configured the streams and is ready to capture.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000052">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative error code otherwise </dd></dl>

</div>
</div>
<a id="ab30b037abfb09bd548c53c9f9196a184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30b037abfb09bd548c53c9f9196a184">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libcamera::PipelineHandler::stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop capturing from all running streams and cancel pending requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera to stop</td></tr>
  </table>
  </dd>
</dl>
<p>This function stops capturing and processing requests immediately. All pending requests are cancelled and complete immediately in an error state.</p>
<dl class="context"><dt><b><a class="el" href="context.html#_context000053">Thread Safety:</a></b></dt><dd>This function is called from the <a class="el" href="classlibcamera_1_1CameraManager.html" title="Provide access and manage all cameras in the system.">CameraManager</a> thread. </dd></dl>

</div>
</div>
<a id="a3080cc9159e9b31d4ea2376903b94efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3080cc9159e9b31d4ea2376903b94efd">&#9670;&nbsp;</a></span>stopDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::stopDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibcamera_1_1Camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop capturing from all running streams. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">camera</td><td>The camera to stop</td></tr>
  </table>
  </dd>
</dl>
<p>This function stops capturing and processing requests immediately. All pending requests are cancelled and complete immediately in an error state. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae78c43450c383e9bb8757cf01c70dc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78c43450c383e9bb8757cf01c70dc4e">&#9670;&nbsp;</a></span>manager_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::PipelineHandler::manager_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classlibcamera_1_1Camera.html" title="Camera device.">Camera</a> manager associated with the pipeline handler. </p>
<p>The camera manager pointer is stored in the pipeline handler for the convenience of pipeline handler implementations. It remains valid and constant for the whole lifetime of the pipeline handler. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/libcamera/internal/<a class="el" href="pipeline__handler_8h_source.html">pipeline_handler.h</a></li>
<li>src/libcamera/pipeline_handler.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
