<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcamera: include/libcamera/base/utils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcamera
   &#160;<span id="projectnumber">v0.3.2+rpt20241101+7-aa9d3ab4</span>
   </div>
   <div id="projectbrief">Supporting cameras in Linux since 2019</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_a19b8593fbb1ff05f8d3ffdb81ecf984.html">libcamera</a></li><li class="navelem"><a class="el" href="dir_f216eccf256e99bbd65d3088a61dbab9.html">base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">utils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous utility functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;chrono&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;sys/time.h&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;libcamera/base/private.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for utils.h:</div>
<div class="dyncontent">
<div class="center"><img src="utils_8h__incl.png" border="0" usemap="#ainclude_2libcamera_2base_2utils_8h" alt=""/></div>
<map name="ainclude_2libcamera_2base_2utils_8h" id="ainclude_2libcamera_2base_2utils_8h">
<area shape="rect" title="Miscellaneous utility functions." alt="" coords="560,5,733,47"/>
<area shape="rect" title=" " alt="" coords="5,95,91,121"/>
<area shape="rect" title=" " alt="" coords="115,95,181,121"/>
<area shape="rect" title=" " alt="" coords="206,95,293,121"/>
<area shape="rect" title=" " alt="" coords="317,95,387,121"/>
<area shape="rect" title=" " alt="" coords="411,95,487,121"/>
<area shape="rect" title=" " alt="" coords="512,95,587,121"/>
<area shape="rect" title=" " alt="" coords="611,95,682,121"/>
<area shape="rect" title=" " alt="" coords="707,95,765,121"/>
<area shape="rect" title=" " alt="" coords="789,95,880,121"/>
<area shape="rect" title=" " alt="" coords="905,95,997,121"/>
<area shape="rect" title=" " alt="" coords="1021,95,1081,121"/>
<area shape="rect" title=" " alt="" coords="1105,95,1167,121"/>
<area shape="rect" href="private_8h_source.html" title=" " alt="" coords="1192,95,1376,121"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="utils_8h__dep__incl.png" border="0" usemap="#ainclude_2libcamera_2base_2utils_8hdep" alt=""/></div>
<map name="ainclude_2libcamera_2base_2utils_8hdep" id="ainclude_2libcamera_2base_2utils_8hdep">
<area shape="rect" title="Miscellaneous utility functions." alt="" coords="3277,5,3450,47"/>
<area shape="rect" href="log_8h.html" title="Logging infrastructure." alt="" coords="1548,95,1721,136"/>
<area shape="rect" href="v4l2__videodevice_8h.html" title="V4L2 Video Device." alt="" coords="33,273,225,315"/>
<area shape="rect" href="ipa__context_8h.html" title="Context and state information shared between the algorithms." alt="" coords="3220,281,3409,307"/>
<area shape="rect" href="libipa_2module_8h.html" title="IPA Module common interface." alt="" coords="3106,191,3277,218"/>
<area shape="rect" href="thread_8h.html" title="Thread support." alt="" coords="2777,95,2950,136"/>
<area shape="rect" href="af_8h.html" title=" " alt="" coords="3332,102,3531,129"/>
<area shape="rect" href="agc_8h.html" title=" " alt="" coords="3613,273,3784,315"/>
<area shape="rect" href="agc__mean__luminance_8h.html" title="Base class implementing mean luminance AEGC." alt="" coords="3744,184,3898,225"/>
<area shape="rect" href="exposure__mode__helper_8h.html" title="Helper class that performs computations relating to exposure." alt="" coords="3867,95,4036,136"/>
<area shape="rect" href="histogram_8h.html" title="Class to represent Histograms and manipulate them." alt="" coords="3605,102,3792,129"/>
<area shape="rect" href="camera__lens_8h.html" title="A camera lens controller." alt="" coords="1472,184,1664,225"/>
<area shape="rect" href="camera__sensor_8h.html" title="A camera sensor." alt="" coords="1605,363,1797,404"/>
<area shape="rect" href="software__isp_8h_source.html" title=" " alt="" coords="1836,452,2043,493"/>
<area shape="rect" href="converter__v4l2__m2m_8h.html" title="V4L2 M2M based converter." alt="" coords="350,184,593,225"/>
<area shape="rect" href="ipa__data__serializer_8h.html" title="IPA Data Serializer." alt="" coords="617,184,809,225"/>
<area shape="rect" href="ipa__manager_8h.html" title="Image Processing Algorithm module manager." alt="" coords="2224,273,2416,315"/>
<area shape="rect" href="ipa__module_8h.html" title="Image Processing Algorithm module." alt="" coords="2224,184,2416,225"/>
<area shape="rect" href="media__device_8h.html" title="Provide a representation of a Linux kernel Media Controller device that exposes the full graph topolo..." alt="" coords="833,184,1025,225"/>
<area shape="rect" href="v4l2__device_8h.html" title="Common base for V4L2 devices and subdevices." alt="" coords="134,184,326,225"/>
<area shape="rect" href="v4l2__subdevice_8h.html" title="V4L2 Subdevice API." alt="" coords="966,273,1158,315"/>
<area shape="rect" href="fc__queue_8h.html" title="Queue of per&#45;frame contexts." alt="" coords="2902,191,3082,218"/>
<area shape="rect" href="interpolator_8h.html" title="Helper class for linear interpolating a set of objects." alt="" coords="1100,191,1296,218"/>
<area shape="rect" href="lsc__polynomial_8h.html" title="LscPolynomial class." alt="" coords="1320,184,1447,225"/>
<area shape="rect" href="matrix_8h.html" title="Matrix class." alt="" coords="1739,191,1903,218"/>
<area shape="rect" href="vector_8h.html" title="Vector class." alt="" coords="1836,281,1998,307"/>
<area shape="rect" href="dma__buf__allocator_8cpp.html" title="dma&#45;buf allocator" alt="" coords="1978,184,2149,225"/>
<area shape="rect" href="debayer_8h_source.html" title=" " alt="" coords="2656,184,2826,225"/>
<area shape="rect" href="software__isp_8cpp.html" title="Simple software ISP implementation." alt="" coords="2234,541,2405,583"/>
<area shape="rect" href="ipu3_2module_8h_source.html" title=" " alt="" coords="3166,370,3329,397"/>
<area shape="rect" href="pwl_8h.html" title="Piecewise linear functions." alt="" coords="1845,370,1989,397"/>
<area shape="rect" href="debayer__cpu_8h_source.html" title=" " alt="" coords="2362,452,2533,493"/>
<area shape="rect" href="internal_2camera__manager_8h.html" title="Internal camera manager support." alt="" coords="2440,184,2632,225"/>
</map>
</div>
</div>
<p><a href="utils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1utils_1_1Duration.html">libcamera::utils::Duration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class from std::chrono::duration that represents a time duration in nanoseconds with double precision.  <a href="classlibcamera_1_1utils_1_1Duration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibcamera_1_1utils_1_1ScopeExitActions.html">libcamera::utils::ScopeExitActions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that performs actions upon destruction.  <a href="classlibcamera_1_1utils_1_1ScopeExitActions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelibcamera"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera.html">libcamera</a></td></tr>
<tr class="memdesc:namespacelibcamera"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top-level libcamera namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7ef185f107a5045b3a044ca02cd2ea98"><td class="memItemLeft" align="right" valign="top"><a id="a7ef185f107a5045b3a044ca02cd2ea98"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a7ef185f107a5045b3a044ca02cd2ea98">libcamera::utils::clock</a> = std::chrono::steady_clock</td></tr>
<tr class="memdesc:a7ef185f107a5045b3a044ca02cd2ea98"><td class="mdescLeft">&#160;</td><td class="mdescRight">The libcamera clock (monotonic) <br /></td></tr>
<tr class="separator:a7ef185f107a5045b3a044ca02cd2ea98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a71f9eb2c27cd6213306d8d2ff7fd0"><td class="memItemLeft" align="right" valign="top"><a id="ad2a71f9eb2c27cd6213306d8d2ff7fd0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#ad2a71f9eb2c27cd6213306d8d2ff7fd0">libcamera::utils::duration</a> = std::chrono::steady_clock::duration</td></tr>
<tr class="memdesc:ad2a71f9eb2c27cd6213306d8d2ff7fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The libcamera duration related to libcamera::utils::clock. <br /></td></tr>
<tr class="separator:ad2a71f9eb2c27cd6213306d8d2ff7fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8294b009381080fdcaed4b0eb8b03224"><td class="memItemLeft" align="right" valign="top"><a id="a8294b009381080fdcaed4b0eb8b03224"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a8294b009381080fdcaed4b0eb8b03224">libcamera::utils::time_point</a> = std::chrono::steady_clock::time_point</td></tr>
<tr class="memdesc:a8294b009381080fdcaed4b0eb8b03224"><td class="mdescLeft">&#160;</td><td class="mdescRight">The libcamera time point related to libcamera::utils::clock. <br /></td></tr>
<tr class="separator:a8294b009381080fdcaed4b0eb8b03224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1d2c8b994fc3be2a2ed92eca41e17d79"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a1d2c8b994fc3be2a2ed92eca41e17d79">libcamera::utils::basename</a> (const char *path)</td></tr>
<tr class="memdesc:a1d2c8b994fc3be2a2ed92eca41e17d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip the directory prefix from the path.  <a href="utils_8h.html#a1d2c8b994fc3be2a2ed92eca41e17d79">More...</a><br /></td></tr>
<tr class="separator:a1d2c8b994fc3be2a2ed92eca41e17d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6981717235fc0bcc1a270b1d77ee9189"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a6981717235fc0bcc1a270b1d77ee9189">libcamera::utils::secure_getenv</a> (const char *name)</td></tr>
<tr class="memdesc:a6981717235fc0bcc1a270b1d77ee9189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an environment variable.  <a href="utils_8h.html#a6981717235fc0bcc1a270b1d77ee9189">More...</a><br /></td></tr>
<tr class="separator:a6981717235fc0bcc1a270b1d77ee9189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9b4d3b9abf4232f49aaf12442d9412"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#afd9b4d3b9abf4232f49aaf12442d9412">libcamera::utils::dirname</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:afd9b4d3b9abf4232f49aaf12442d9412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the dirname portion of a path.  <a href="utils_8h.html#afd9b4d3b9abf4232f49aaf12442d9412">More...</a><br /></td></tr>
<tr class="separator:afd9b4d3b9abf4232f49aaf12442d9412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9682828250eb4214779ddc2b9564415e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9682828250eb4214779ddc2b9564415e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename T::key_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utils_8h.html#a9682828250eb4214779ddc2b9564415e">libcamera::utils::map_keys</a> (const T &amp;map)</td></tr>
<tr class="memdesc:a9682828250eb4214779ddc2b9564415e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the keys of a std::map&lt;&gt;  <a href="utils_8h.html#a9682828250eb4214779ddc2b9564415e">More...</a><br /></td></tr>
<tr class="separator:a9682828250eb4214779ddc2b9564415e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f4325ea534abfe9fb482799ecc8502"><td class="memTemplParams" colspan="2">template&lt;class InputIt1 , class InputIt2 &gt; </td></tr>
<tr class="memitem:a83f4325ea534abfe9fb482799ecc8502"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utils_8h.html#a83f4325ea534abfe9fb482799ecc8502">libcamera::utils::set_overlap</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2)</td></tr>
<tr class="memdesc:a83f4325ea534abfe9fb482799ecc8502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of elements in the intersection of two ranges.  <a href="utils_8h.html#a83f4325ea534abfe9fb482799ecc8502">More...</a><br /></td></tr>
<tr class="separator:a83f4325ea534abfe9fb482799ecc8502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c2e92206b340eb5d61ed0de0ad8ada"><td class="memItemLeft" align="right" valign="top">struct timespec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#aa6c2e92206b340eb5d61ed0de0ad8ada">libcamera::utils::duration_to_timespec</a> (const duration &amp;value)</td></tr>
<tr class="memdesc:aa6c2e92206b340eb5d61ed0de0ad8ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a duration to a timespec.  <a href="utils_8h.html#aa6c2e92206b340eb5d61ed0de0ad8ada">More...</a><br /></td></tr>
<tr class="separator:aa6c2e92206b340eb5d61ed0de0ad8ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286d03ee13e24290a5841b114c614e59"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a286d03ee13e24290a5841b114c614e59">libcamera::utils::time_point_to_string</a> (const time_point &amp;time)</td></tr>
<tr class="memdesc:a286d03ee13e24290a5841b114c614e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a time point to a string representation.  <a href="utils_8h.html#a286d03ee13e24290a5841b114c614e59">More...</a><br /></td></tr>
<tr class="separator:a286d03ee13e24290a5841b114c614e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71db1210216daf6c892326ffe34a3a3"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae71db1210216daf6c892326ffe34a3a3"><td class="memTemplItemLeft" align="right" valign="top">_hex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utils_8h.html#ae71db1210216daf6c892326ffe34a3a3">libcamera::utils::hex</a> (T value, unsigned int width=0)</td></tr>
<tr class="memdesc:ae71db1210216daf6c892326ffe34a3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an hexadecimal value to an output string.  <a href="utils_8h.html#ae71db1210216daf6c892326ffe34a3a3">More...</a><br /></td></tr>
<tr class="separator:ae71db1210216daf6c892326ffe34a3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b34c72abd79fa88b3039bf05964de1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a68b34c72abd79fa88b3039bf05964de1">libcamera::utils::strlcpy</a> (char *dst, const char *src, size_t size)</td></tr>
<tr class="memdesc:a68b34c72abd79fa88b3039bf05964de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string with a size limit.  <a href="utils_8h.html#a68b34c72abd79fa88b3039bf05964de1">More...</a><br /></td></tr>
<tr class="separator:a68b34c72abd79fa88b3039bf05964de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8d1a0773f958967efd22cfb90d81fc"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryOp &gt; </td></tr>
<tr class="memitem:ace8d1a0773f958967efd22cfb90d81fc"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utils_8h.html#ace8d1a0773f958967efd22cfb90d81fc">libcamera::utils::join</a> (const Container &amp;items, const std::string &amp;sep, UnaryOp op=nullptr)</td></tr>
<tr class="memdesc:ace8d1a0773f958967efd22cfb90d81fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join elements of a container in a string with a separator.  <a href="utils_8h.html#ace8d1a0773f958967efd22cfb90d81fc">More...</a><br /></td></tr>
<tr class="separator:ace8d1a0773f958967efd22cfb90d81fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24701cae6640674865484b40b2325a7d"><td class="memItemLeft" align="right" valign="top">details::StringSplitter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a24701cae6640674865484b40b2325a7d">libcamera::utils::split</a> (const std::string &amp;str, const std::string &amp;delim)</td></tr>
<tr class="memdesc:a24701cae6640674865484b40b2325a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string based on a delimiter.  <a href="utils_8h.html#a24701cae6640674865484b40b2325a7d">More...</a><br /></td></tr>
<tr class="separator:a24701cae6640674865484b40b2325a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546d3faa29d241f8c5ad2784cdcae8d4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a546d3faa29d241f8c5ad2784cdcae8d4">libcamera::utils::toAscii</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a546d3faa29d241f8c5ad2784cdcae8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any non-ASCII characters from a string.  <a href="utils_8h.html#a546d3faa29d241f8c5ad2784cdcae8d4">More...</a><br /></td></tr>
<tr class="separator:a546d3faa29d241f8c5ad2784cdcae8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e149c6ca26755ffd6b448778c4fb63"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#aa4e149c6ca26755ffd6b448778c4fb63">libcamera::utils::libcameraBuildPath</a> ()</td></tr>
<tr class="memdesc:aa4e149c6ca26755ffd6b448778c4fb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the path to the build directory.  <a href="utils_8h.html#aa4e149c6ca26755ffd6b448778c4fb63">More...</a><br /></td></tr>
<tr class="separator:aa4e149c6ca26755ffd6b448778c4fb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4163d8b770aad3f746637c59a5f228d2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a4163d8b770aad3f746637c59a5f228d2">libcamera::utils::libcameraSourcePath</a> ()</td></tr>
<tr class="memdesc:a4163d8b770aad3f746637c59a5f228d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the path to the source directory.  <a href="utils_8h.html#a4163d8b770aad3f746637c59a5f228d2">More...</a><br /></td></tr>
<tr class="separator:a4163d8b770aad3f746637c59a5f228d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2950834476fdd93908c4a275edccac4a"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a2950834476fdd93908c4a275edccac4a">libcamera::utils::alignDown</a> (unsigned int value, unsigned int alignment)</td></tr>
<tr class="memdesc:a2950834476fdd93908c4a275edccac4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <em>value</em> down to <em>alignment</em>.  <a href="utils_8h.html#a2950834476fdd93908c4a275edccac4a">More...</a><br /></td></tr>
<tr class="separator:a2950834476fdd93908c4a275edccac4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973e18b140de0499255673e3a2f4d861"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#a973e18b140de0499255673e3a2f4d861">libcamera::utils::alignUp</a> (unsigned int value, unsigned int alignment)</td></tr>
<tr class="memdesc:a973e18b140de0499255673e3a2f4d861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <em>value</em> up to <em>alignment</em>.  <a href="utils_8h.html#a973e18b140de0499255673e3a2f4d861">More...</a><br /></td></tr>
<tr class="separator:a973e18b140de0499255673e3a2f4d861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77ea11443473007cc0127e21a6a3e51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad77ea11443473007cc0127e21a6a3e51"><td class="memTemplItemLeft" align="right" valign="top">details::reverse_adapter&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utils_8h.html#ad77ea11443473007cc0127e21a6a3e51">libcamera::utils::reverse</a> (T &amp;&amp;iterable)</td></tr>
<tr class="memdesc:ad77ea11443473007cc0127e21a6a3e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an iterable to reverse iteration in a range-based loop.  <a href="utils_8h.html#ad77ea11443473007cc0127e21a6a3e51">More...</a><br /></td></tr>
<tr class="separator:ad77ea11443473007cc0127e21a6a3e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae904c8027790ede4383b7b1d05ae279"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae904c8027790ede4383b7b1d05ae279"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utils_8h.html#aae904c8027790ede4383b7b1d05ae279">libcamera::utils::enumerate</a> (T &amp;iterable) -&gt; details::enumerate_adapter&lt; decltype(iterable.begin())&gt;</td></tr>
<tr class="memdesc:aae904c8027790ede4383b7b1d05ae279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an iterable to enumerate index and value in a range-based loop.  <a href="utils_8h.html#aae904c8027790ede4383b7b1d05ae279">More...</a><br /></td></tr>
<tr class="separator:aae904c8027790ede4383b7b1d05ae279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32a1f64e6a68944b89779c4bbe895e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac32a1f64e6a68944b89779c4bbe895e7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utils_8h.html#ac32a1f64e6a68944b89779c4bbe895e7">libcamera::utils::abs_diff</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ac32a1f64e6a68944b89779c4bbe895e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the absolute value of the difference between two elements.  <a href="utils_8h.html#ac32a1f64e6a68944b89779c4bbe895e7">More...</a><br /></td></tr>
<tr class="separator:ac32a1f64e6a68944b89779c4bbe895e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeccfc6cdef233fd9c7a384f1b2744ce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8h.html#adeccfc6cdef233fd9c7a384f1b2744ce">libcamera::utils::strtod</a> (const char *__restrict nptr, char **__restrict endptr)</td></tr>
<tr class="memdesc:adeccfc6cdef233fd9c7a384f1b2744ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a double independently of the current locale.  <a href="utils_8h.html#adeccfc6cdef233fd9c7a384f1b2744ce">More...</a><br /></td></tr>
<tr class="separator:adeccfc6cdef233fd9c7a384f1b2744ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e36eb7165ff23ffa3ff9551a0af76fc"><td class="memTemplParams" colspan="2">template&lt;class Enum &gt; </td></tr>
<tr class="memitem:a5e36eb7165ff23ffa3ff9551a0af76fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::underlying_type_t&lt; Enum &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utils_8h.html#a5e36eb7165ff23ffa3ff9551a0af76fc">libcamera::utils::to_underlying</a> (Enum e) noexcept</td></tr>
<tr class="memdesc:a5e36eb7165ff23ffa3ff9551a0af76fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an enumeration to its underlygin type.  <a href="utils_8h.html#a5e36eb7165ff23ffa3ff9551a0af76fc">More...</a><br /></td></tr>
<tr class="separator:a5e36eb7165ff23ffa3ff9551a0af76fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Miscellaneous utility functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac32a1f64e6a68944b89779c4bbe895e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32a1f64e6a68944b89779c4bbe895e7">&#9670;&nbsp;</a></span>abs_diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libcamera::utils::abs_diff </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the absolute value of the difference between two elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second element</td></tr>
  </table>
  </dd>
</dl>
<p>This function calculates the absolute value of the difference between two elements of the same type, in such a way that a negative value will never occur during the calculation.</p>
<p>This is inspired by the <a class="el" href="utils_8h.html#ac32a1f64e6a68944b89779c4bbe895e7" title="Calculates the absolute value of the difference between two elements.">std::abs_diff()</a> candidate proposed in N4318 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4318.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4318.pdf</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of the difference of the two parameters <em>a</em> and <em>b</em> </dd></dl>

</div>
</div>
<a id="a2950834476fdd93908c4a275edccac4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2950834476fdd93908c4a275edccac4a">&#9670;&nbsp;</a></span>alignDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::utils::alignDown </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Align <em>value</em> down to <em>alignment</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to align </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value rounded down to the nearest multiple of <em>alignment</em> </dd></dl>

</div>
</div>
<a id="a973e18b140de0499255673e3a2f4d861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973e18b140de0499255673e3a2f4d861">&#9670;&nbsp;</a></span>alignUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::utils::alignUp </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Align <em>value</em> up to <em>alignment</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to align </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>The alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value rounded up to the nearest multiple of <em>alignment</em> </dd></dl>

</div>
</div>
<a id="a1d2c8b994fc3be2a2ed92eca41e17d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2c8b994fc3be2a2ed92eca41e17d79">&#9670;&nbsp;</a></span>basename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * libcamera::utils::basename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip the directory prefix from the path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to process</td></tr>
  </table>
  </dd>
</dl>
<p>basename is implemented differently across different C libraries. This implementation matches the one provided by the GNU libc, and does not modify its input parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer within the given path without any leading directory components. </dd></dl>

</div>
</div>
<a id="afd9b4d3b9abf4232f49aaf12442d9412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9b4d3b9abf4232f49aaf12442d9412">&#9670;&nbsp;</a></span>dirname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string libcamera::utils::dirname </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify the dirname portion of a path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The full path to parse</td></tr>
  </table>
  </dd>
</dl>
<p>This function conforms with the behaviour of the dirname() function as defined by POSIX.</p>
<dl class="section return"><dt>Returns</dt><dd>A string of the directory component of the path </dd></dl>

</div>
</div>
<a id="aa6c2e92206b340eb5d61ed0de0ad8ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c2e92206b340eb5d61ed0de0ad8ada">&#9670;&nbsp;</a></span>duration_to_timespec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct timespec libcamera::utils::duration_to_timespec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="utils_8h.html#ad2a71f9eb2c27cd6213306d8d2ff7fd0">duration</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a duration to a timespec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The duration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A timespec expressing the duration </dd></dl>

</div>
</div>
<a id="aae904c8027790ede4383b7b1d05ae279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae904c8027790ede4383b7b1d05ae279">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libcamera::utils::enumerate </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td> -&gt; details::enumerate_adapter&lt;decltype(iterable.begin())&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap an iterable to enumerate index and value in a range-based loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterable</td><td>The iterable</td></tr>
  </table>
  </dd>
</dl>
<p>Range-based for loops are handy and widely preferred in C++, but are limited in their ability to replace for loops that require access to a loop counter. The <a class="el" href="utils_8h.html#aae904c8027790ede4383b7b1d05ae279" title="Wrap an iterable to enumerate index and value in a range-based loop.">enumerate()</a> function solves this problem by wrapping the <em>iterable</em> in an adapter that, when used as a range-expression, will provide iterators whose value_type is a pair of index and value reference.</p>
<p>The iterable must support std::begin() and std::end(). This includes all containers provided by the standard C++ library, as well as C-style arrays.</p>
<p>A typical usage pattern would use structured binding to store the index and value in two separate variables:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; values = ...;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> [index, value] : utils::enumerate(values)) {</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the argument to <a class="el" href="utils_8h.html#aae904c8027790ede4383b7b1d05ae279" title="Wrap an iterable to enumerate index and value in a range-based loop.">enumerate()</a> has to be an lvalue, as the lifetime of any rvalue would not be extended to the whole for loop. The compiler will complain if an rvalue is passed to the function, in which case it should be stored in a local variable before the loop.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of unspecified type that, when used in a range-based for loop, iterates over an indexed view of the <em>iterable</em> </dd></dl>

</div>
</div>
<a id="ae71db1210216daf6c892326ffe34a3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71db1210216daf6c892326ffe34a3a3">&#9670;&nbsp;</a></span>hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libcamera::utils::hex </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an hexadecimal value to an output string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value </td></tr>
    <tr><td class="paramname">width</td><td>The width</td></tr>
  </table>
  </dd>
</dl>
<p>Return an object of unspecified type such that, if <em>os</em> is the name of an output stream of type std::ostream, and T is an integer type, then the expression</p>
<div class="fragment"><div class="line">os &lt;&lt; utils::hex(value)</div>
</div><!-- fragment --><p>will output the <em>value</em> to the stream in hexadecimal form with the base prefix and the filling character set to '0'. The field width is set to <em>width</em> if specified to a non-zero value, or to the native width of type T otherwise. The <em>os</em> stream configuration is not modified. </p>

</div>
</div>
<a id="ace8d1a0773f958967efd22cfb90d81fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8d1a0773f958967efd22cfb90d81fc">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Container, typename UnaryOp &gt; std::string libcamera::utils::join </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>op</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join elements of a container in a string with a separator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">items</td><td>The container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sep</td><td>The separator to add between elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>A function that converts individual elements to strings</td></tr>
  </table>
  </dd>
</dl>
<p>This function joins all elements in the <em>items</em> container into a string and returns it. The <em>sep</em> separator is added between elements. If the container elements are not implicitly convertible to std::string, the <em>op</em> function shall be provided to perform conversion of elements to std::string.</p>
<dl class="section return"><dt>Returns</dt><dd>A string that concatenates all elements in the container </dd></dl>

</div>
</div>
<a id="aa4e149c6ca26755ffd6b448778c4fb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e149c6ca26755ffd6b448778c4fb63">&#9670;&nbsp;</a></span>libcameraBuildPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string libcamera::utils::libcameraBuildPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the path to the build directory. </p>
<p>During development, it is useful to run libcamera binaries directly from the build directory without installing them. This function helps components that need to locate resources in the build tree, such as IPA modules or IPA proxy workers, by providing them with the path to the root of the build directory. Callers can then use it to complement or override searches in system-wide directories.</p>
<p>If libcamera has been installed, the build directory path is not available and this function returns an empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>The path to the build directory if running from a build, or an empty string otherwise </dd></dl>

</div>
</div>
<a id="a4163d8b770aad3f746637c59a5f228d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4163d8b770aad3f746637c59a5f228d2">&#9670;&nbsp;</a></span>libcameraSourcePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string libcamera::utils::libcameraSourcePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the path to the source directory. </p>
<p>During development, it is useful to run libcamera binaries directly from the build directory without installing them. This function helps components that need to locate resources in the source tree, such as IPA configuration files, by providing them with the path to the root of the source directory. Callers can then use it to complement or override searches in system-wide directories.</p>
<p>If libcamera has been installed, the source directory path is not available and this function returns an empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>The path to the source directory if running from a build directory, or an empty string otherwise </dd></dl>

</div>
</div>
<a id="a9682828250eb4214779ddc2b9564415e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9682828250eb4214779ddc2b9564415e">&#9670;&nbsp;</a></span>map_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename T::key_type &gt; libcamera::utils::map_keys </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the keys of a std::map&lt;&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The map whose keys to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;&gt; containing the keys of <em>map</em> </dd></dl>

</div>
</div>
<a id="ad77ea11443473007cc0127e21a6a3e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77ea11443473007cc0127e21a6a3e51">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libcamera::utils::reverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap an iterable to reverse iteration in a range-based loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterable</td><td>The iterable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of unspecified type that, when used in a range-based for loop, will cause the loop to iterate over the <em>iterable</em> in reverse order </dd></dl>

</div>
</div>
<a id="a6981717235fc0bcc1a270b1d77ee9189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6981717235fc0bcc1a270b1d77ee9189">&#9670;&nbsp;</a></span>secure_getenv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * libcamera::utils::secure_getenv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an environment variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the variable to return</td></tr>
  </table>
  </dd>
</dl>
<p>The environment list is searched to find the variable 'name', and the corresponding string is returned.</p>
<p>If 'secure execution' is required then this function always returns NULL to avoid vulnerabilities that could occur if set-user-ID or set-group-ID programs accidentally trust the environment.</p>
<dl class="section note"><dt>Note</dt><dd>Not all platforms may support the features required to implement the secure execution check, in which case this function behaves as getenv(). A notable example of this is Android.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the value in the environment or NULL if the requested environment variable doesn't exist or if secure execution is required. </dd></dl>

</div>
</div>
<a id="a83f4325ea534abfe9fb482799ecc8502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f4325ea534abfe9fb482799ecc8502">&#9670;&nbsp;</a></span>set_overlap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt1 , class InputIt2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libcamera::utils::set_overlap </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of elements in the intersection of two ranges. </p>
<p>Count the number of elements in the intersection of the sorted ranges [<em>first1</em>, <em>last1</em>) and [<em>first1</em>, <em>last2</em>). Elements are compared using operator&lt; and the ranges must be sorted with respect to the same.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the intersection of the two ranges </dd></dl>

</div>
</div>
<a id="a24701cae6640674865484b40b2325a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24701cae6640674865484b40b2325a7d">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">details::StringSplitter libcamera::utils::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string based on a delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>The delimiter string</td></tr>
  </table>
  </dd>
</dl>
<p>This function splits the string <em>str</em> into substrings based on the delimiter <em>delim</em>. It returns an object of unspecified type that can be used in a range-based for loop and yields the substrings in sequence.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that can be used in a range-based for loop to iterate over the substrings </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Try to avoid copies of str and delim </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Try to avoid copies of str and delim </dd></dl>

</div>
</div>
<a id="a68b34c72abd79fa88b3039bf05964de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b34c72abd79fa88b3039bf05964de1">&#9670;&nbsp;</a></span>strlcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t libcamera::utils::strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string with a size limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>The destination string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the destination string</td></tr>
  </table>
  </dd>
</dl>
<p>This function copies the null-terminated string <em>src</em> to <em>dst</em> with a limit of <em>size</em> - 1 characters, and null-terminates the result if <em>size</em> is larger than 0. If <em>src</em> is larger than <em>size</em> - 1, <em>dst</em> is truncated.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of <em>src</em> </dd></dl>

</div>
</div>
<a id="adeccfc6cdef233fd9c7a384f1b2744ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeccfc6cdef233fd9c7a384f1b2744ce">&#9670;&nbsp;</a></span>strtod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcamera::utils::strtod </td>
          <td>(</td>
          <td class="paramtype">const char *__restrict&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **__restrict&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a double independently of the current locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nptr</td><td>The string to convert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endptr</td><td>Pointer to trailing portion of the string after conversion</td></tr>
  </table>
  </dd>
</dl>
<p>This function is a locale-independent version of the <a class="el" href="utils_8h.html#adeccfc6cdef233fd9c7a384f1b2744ce" title="Convert a string to a double independently of the current locale.">std::strtod()</a> function. It behaves as the standard function, but uses the "C" locale instead of the current locale.</p>
<dl class="section return"><dt>Returns</dt><dd>The converted value, if any, or 0.0 if the conversion failed. </dd></dl>

</div>
</div>
<a id="a286d03ee13e24290a5841b114c614e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286d03ee13e24290a5841b114c614e59">&#9670;&nbsp;</a></span>time_point_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string libcamera::utils::time_point_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="utils_8h.html#a8294b009381080fdcaed4b0eb8b03224">time_point</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a time point to a string representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the time point in hh:mm:ss.nanoseconds format </dd></dl>

</div>
</div>
<a id="a5e36eb7165ff23ffa3ff9551a0af76fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e36eb7165ff23ffa3ff9551a0af76fc">&#9670;&nbsp;</a></span>to_underlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Enum &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::utils::to_underlying </td>
          <td>(</td>
          <td class="paramtype">Enum&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an enumeration to its underlygin type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Enumeration value to convert</td></tr>
  </table>
  </dd>
</dl>
<p>This function is equivalent to the C++23 <a class="el" href="utils_8h.html#a5e36eb7165ff23ffa3ff9551a0af76fc" title="Convert an enumeration to its underlygin type.">std::to_underlying()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The value of e converted to its underlying type </dd></dl>

</div>
</div>
<a id="a546d3faa29d241f8c5ad2784cdcae8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546d3faa29d241f8c5ad2784cdcae8d4">&#9670;&nbsp;</a></span>toAscii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string libcamera::utils::toAscii </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove any non-ASCII characters from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to strip</td></tr>
  </table>
  </dd>
</dl>
<p>Remove all non-ASCII characters from a string.</p>
<dl class="section return"><dt>Returns</dt><dd>A string equal to <em>str</em> stripped out of all non-ASCII characters </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
