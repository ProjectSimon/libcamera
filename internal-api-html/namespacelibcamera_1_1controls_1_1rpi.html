<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcamera: libcamera::controls::rpi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libcamera<span id="projectnumber">&#160;v0.4.0+5314-fc77c53d-nvm</span>
   </div>
   <div id="projectbrief">Supporting cameras in Linux since 2019</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibcamera.html">libcamera</a></li><li class="navelem"><a class="el" href="namespacelibcamera_1_1controls.html">controls</a></li><li class="navelem"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html">rpi</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">libcamera::controls::rpi Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for rpi controls.  
<a href="namespacelibcamera_1_1controls_1_1rpi.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a39a82ef7cd9b46d56653f12442b57779" id="r_a39a82ef7cd9b46d56653f12442b57779"><td class="memItemLeft" align="right" valign="top"><a id="a39a82ef7cd9b46d56653f12442b57779" name="a39a82ef7cd9b46d56653f12442b57779"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>STATS_OUTPUT_ENABLE</b> = 20001
, <b>BCM2835_STATS_OUTPUT</b> = 20002
, <b>SCALER_CROPS</b> = 20003
, <b>PISP_STATS_OUTPUT</b> = 20004
, <br />
&#160;&#160;<b>CNN_OUTPUT_TENSOR</b> = 20005
, <b>CNN_OUTPUT_TENSOR_INFO</b> = 20006
, <b>CNN_ENABLE_INPUT_TENSOR</b> = 20007
, <b>CNN_INPUT_TENSOR</b> = 20008
, <br />
&#160;&#160;<b>CNN_INPUT_TENSOR_INFO</b> = 20009
, <b>CNN_KPI_INFO</b> = 20010
, <b>SYNC_MODE</b> = 20011
, <b>SYNC_READY</b> = 20012
, <br />
&#160;&#160;<b>SYNC_TIMER</b> = 20013
, <b>SYNC_FRAMES</b> = 20014
<br />
 }</td></tr>
<tr class="separator:a39a82ef7cd9b46d56653f12442b57779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e3bda5145da2ac37ce6660438e0e0e" id="r_aa9e3bda5145da2ac37ce6660438e0e0e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#aa9e3bda5145da2ac37ce6660438e0e0e">SyncModeEnum</a> { <a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#aa9e3bda5145da2ac37ce6660438e0e0eabd02170a40e7c33b8c151056a0fc2558">SyncModeOff</a> = 0
, <a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#aa9e3bda5145da2ac37ce6660438e0e0ea4c9660b2f204cf18b6886b5984c68eb1">SyncModeServer</a> = 1
, <a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#aa9e3bda5145da2ac37ce6660438e0e0eaac1eb70cebe2eeca93895580e7cf5277">SyncModeClient</a> = 2
 }</td></tr>
<tr class="memdesc:aa9e3bda5145da2ac37ce6660438e0e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported SyncMode values.  <a href="namespacelibcamera_1_1controls_1_1rpi.html#aa9e3bda5145da2ac37ce6660438e0e0e">More...</a><br /></td></tr>
<tr class="separator:aa9e3bda5145da2ac37ce6660438e0e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac020d0d9da4ee8af51c76dff0034814b" id="r_ac020d0d9da4ee8af51c76dff0034814b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ac020d0d9da4ee8af51c76dff0034814b">StatsOutputEnable</a></td></tr>
<tr class="memdesc:ac020d0d9da4ee8af51c76dff0034814b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles the Raspberry Pi IPA to output the hardware generated statistics.  <br /></td></tr>
<tr class="separator:ac020d0d9da4ee8af51c76dff0034814b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd959115e9cab5156a7d38879d89c45e" id="r_abd959115e9cab5156a7d38879d89c45e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#abd959115e9cab5156a7d38879d89c45e">Bcm2835StatsOutput</a></td></tr>
<tr class="memdesc:abd959115e9cab5156a7d38879d89c45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Span of the BCM2835 ISP generated statistics for the current frame.  <br /></td></tr>
<tr class="separator:abd959115e9cab5156a7d38879d89c45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6a6067d2d7e039d27c8bb447723099" id="r_ada6a6067d2d7e039d27c8bb447723099"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const <a class="el" href="classlibcamera_1_1Rectangle.html">Rectangle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ada6a6067d2d7e039d27c8bb447723099">ScalerCrops</a></td></tr>
<tr class="memdesc:ada6a6067d2d7e039d27c8bb447723099"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of rectangles, where each singular value has identical functionality to the ScalerCrop control. This control allows the Raspberry Pi pipeline handler to control individual scaler crops per output stream.  <br /></td></tr>
<tr class="separator:ada6a6067d2d7e039d27c8bb447723099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f44d02badac06e27db57838ba53dc7" id="r_a60f44d02badac06e27db57838ba53dc7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a60f44d02badac06e27db57838ba53dc7">PispStatsOutput</a></td></tr>
<tr class="memdesc:a60f44d02badac06e27db57838ba53dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Span of the PiSP Frontend ISP generated statistics for the current frame. This is sent in the <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request.">Request</a> metadata if the StatsOutputEnable is set to true. The statistics struct definition can be found in <a href="https://github.com/raspberrypi/libpisp/blob/main/src/libpisp/frontend/pisp_statistics.h">https://github.com/raspberrypi/libpisp/blob/main/src/libpisp/frontend/pisp_statistics.h</a>.  <br /></td></tr>
<tr class="separator:a60f44d02badac06e27db57838ba53dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ff2a4ff6a832d6e6a669e4ef3d75ce" id="r_a46ff2a4ff6a832d6e6a669e4ef3d75ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a46ff2a4ff6a832d6e6a669e4ef3d75ce">CnnOutputTensor</a></td></tr>
<tr class="memdesc:a46ff2a4ff6a832d6e6a669e4ef3d75ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This control returns a span of floating point values that represent the output tensors from a Convolutional Neural Network (CNN). The size and format of this array of values is entirely dependent on the neural network used, and further post-processing may need to be performed at the application level to generate the final desired output. This control is agnostic of the hardware or software used to generate the output tensors.  <br /></td></tr>
<tr class="separator:a46ff2a4ff6a832d6e6a669e4ef3d75ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb72d9f9a8b9641fa1c82ba65824f3" id="r_ad3fb72d9f9a8b9641fa1c82ba65824f3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ad3fb72d9f9a8b9641fa1c82ba65824f3">CnnOutputTensorInfo</a></td></tr>
<tr class="memdesc:ad3fb72d9f9a8b9641fa1c82ba65824f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This control returns the structure of the CnnOutputTensor. This structure takes the following form:  <br /></td></tr>
<tr class="separator:ad3fb72d9f9a8b9641fa1c82ba65824f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819566d8ac8ec8f7dbe66d3d6532d3fc" id="r_a819566d8ac8ec8f7dbe66d3d6532d3fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a819566d8ac8ec8f7dbe66d3d6532d3fc">CnnEnableInputTensor</a></td></tr>
<tr class="memdesc:a819566d8ac8ec8f7dbe66d3d6532d3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to control if the IPA returns the input tensor used by the CNN to generate the output tensors via the CnnInputTensor control. Because the input tensor may be relatively large, for efficiency reason avoid enabling input tensor output unless required for debugging purposes.  <br /></td></tr>
<tr class="separator:a819566d8ac8ec8f7dbe66d3d6532d3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0b28aa51951207964dfd51841b30d6" id="r_a9f0b28aa51951207964dfd51841b30d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a9f0b28aa51951207964dfd51841b30d6">CnnInputTensor</a></td></tr>
<tr class="memdesc:a9f0b28aa51951207964dfd51841b30d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This control returns a span of uint8_t pixel values that represent the input tensor for a Convolutional Neural Network (CNN). The size and format of this array of values is entirely dependent on the neural network used, and further post-processing (e.g. pixel normalisations) may need to be performed at the application level to generate the final input image.  <br /></td></tr>
<tr class="separator:a9f0b28aa51951207964dfd51841b30d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99a16630bd42167d9d91c418911ab1e" id="r_aa99a16630bd42167d9d91c418911ab1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#aa99a16630bd42167d9d91c418911ab1e">CnnInputTensorInfo</a></td></tr>
<tr class="memdesc:aa99a16630bd42167d9d91c418911ab1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This control returns the structure of the CnnInputTensor. This structure takes the following form:  <br /></td></tr>
<tr class="separator:aa99a16630bd42167d9d91c418911ab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bea4715c5c5814b48a687f7181db2dd" id="r_a4bea4715c5c5814b48a687f7181db2dd"><td class="memItemLeft" align="right" valign="top"><a id="a4bea4715c5c5814b48a687f7181db2dd" name="a4bea4715c5c5814b48a687f7181db2dd"></a>
const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; Span&lt; const int32_t, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CnnKpiInfo</b></td></tr>
<tr class="memdesc:a4bea4715c5c5814b48a687f7181db2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This control returns performance metrics for the CNN processing stage. Two values are returned in this span, the runtime of the CNN/DNN stage and the DSP stage in milliseconds. <br /></td></tr>
<tr class="separator:a4bea4715c5c5814b48a687f7181db2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91208c96af8702e1e1ac78fc29cd64b" id="r_ad91208c96af8702e1e1ac78fc29cd64b"><td class="memItemLeft" align="right" valign="top"><a id="ad91208c96af8702e1e1ac78fc29cd64b" name="ad91208c96af8702e1e1ac78fc29cd64b"></a>
const std::array&lt; const <a class="el" href="classlibcamera_1_1ControlValue.html">ControlValue</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SyncModeValues</b></td></tr>
<tr class="memdesc:ad91208c96af8702e1e1ac78fc29cd64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all SyncMode supported values. <br /></td></tr>
<tr class="separator:ad91208c96af8702e1e1ac78fc29cd64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e07bd2ab949cb93767c966b978086f" id="r_ac0e07bd2ab949cb93767c966b978086f"><td class="memItemLeft" align="right" valign="top"><a id="ac0e07bd2ab949cb93767c966b978086f" name="ac0e07bd2ab949cb93767c966b978086f"></a>
const std::map&lt; std::string, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SyncModeNameValueMap</b></td></tr>
<tr class="memdesc:ac0e07bd2ab949cb93767c966b978086f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all SyncMode supported value names (in std::string format) to value. <br /></td></tr>
<tr class="separator:ac0e07bd2ab949cb93767c966b978086f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9df2cf6632619ea60bbb2c4eb08163" id="r_a6a9df2cf6632619ea60bbb2c4eb08163"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a6a9df2cf6632619ea60bbb2c4eb08163">SyncMode</a></td></tr>
<tr class="memdesc:a6a9df2cf6632619ea60bbb2c4eb08163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable camera synchronisation ("sync") mode.  <br /></td></tr>
<tr class="separator:a6a9df2cf6632619ea60bbb2c4eb08163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fe9e06097330ea2ef10034cc796662" id="r_a15fe9e06097330ea2ef10034cc796662"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a15fe9e06097330ea2ef10034cc796662">SyncReady</a></td></tr>
<tr class="memdesc:a15fe9e06097330ea2ef10034cc796662"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using the camera synchronisation algorithm, the server broadcasts timing information to the clients. This also includes the time (some number of frames in the future, called the "ready time") at which the server will signal its controlling application, using this control, to start using the image frames.  <br /></td></tr>
<tr class="separator:a15fe9e06097330ea2ef10034cc796662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd88e038a84731276803b902314793d0" id="r_afd88e038a84731276803b902314793d0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#afd88e038a84731276803b902314793d0">SyncTimer</a></td></tr>
<tr class="memdesc:afd88e038a84731276803b902314793d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This reports the amount of time, in microseconds, until the "ready
time", at which the server and client will signal their controlling applications that the frames are now synchronised and should be used. The value may be refined slightly over time, becoming more precise as the "ready time" approaches.  <br /></td></tr>
<tr class="separator:afd88e038a84731276803b902314793d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45ec3457f3ce0d0d705520abec654ce" id="r_ab45ec3457f3ce0d0d705520abec654ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibcamera_1_1Control.html">Control</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ab45ec3457f3ce0d0d705520abec654ce">SyncFrames</a></td></tr>
<tr class="memdesc:ab45ec3457f3ce0d0d705520abec654ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of frames the server should wait, after enabling SyncModeServer, before signalling (via the SyncReady control) that frames should be used. This therefore determines the "ready time" for all synchronised cameras.  <br /></td></tr>
<tr class="separator:ab45ec3457f3ce0d0d705520abec654ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for rpi controls. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa9e3bda5145da2ac37ce6660438e0e0e" name="aa9e3bda5145da2ac37ce6660438e0e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e3bda5145da2ac37ce6660438e0e0e">&#9670;&#160;</a></span>SyncModeEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#aa9e3bda5145da2ac37ce6660438e0e0e">libcamera::controls::rpi::SyncModeEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported SyncMode values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa9e3bda5145da2ac37ce6660438e0e0eabd02170a40e7c33b8c151056a0fc2558" name="aa9e3bda5145da2ac37ce6660438e0e0eabd02170a40e7c33b8c151056a0fc2558"></a>SyncModeOff&#160;</td><td class="fielddoc"><p>Disable sync mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa9e3bda5145da2ac37ce6660438e0e0ea4c9660b2f204cf18b6886b5984c68eb1" name="aa9e3bda5145da2ac37ce6660438e0e0ea4c9660b2f204cf18b6886b5984c68eb1"></a>SyncModeServer&#160;</td><td class="fielddoc"><p>Enable sync mode, act as server. The server broadcasts timing messages to any clients that are listening, so that the clients can synchronise their camera frames with the server's. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa9e3bda5145da2ac37ce6660438e0e0eaac1eb70cebe2eeca93895580e7cf5277" name="aa9e3bda5145da2ac37ce6660438e0e0eaac1eb70cebe2eeca93895580e7cf5277"></a>SyncModeClient&#160;</td><td class="fielddoc"><p>Enable sync mode, act as client. A client listens for any server messages, and arranges for its camera frames to synchronise as closely as possible with the server's. Many clients can listen out for the same server. Clients can also be started ahead of any servers, causing them merely to wait for the server to start. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abd959115e9cab5156a7d38879d89c45e" name="abd959115e9cab5156a7d38879d89c45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd959115e9cab5156a7d38879d89c45e">&#9670;&#160;</a></span>Bcm2835StatsOutput</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::Bcm2835StatsOutput</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Span of the BCM2835 ISP generated statistics for the current frame. </p>
<p>This is sent in the <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request.">Request</a> metadata if the StatsOutputEnable is set to true. The statistics struct definition can be found in include/linux/bcm2835-isp.h.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ac020d0d9da4ee8af51c76dff0034814b" title="Toggles the Raspberry Pi IPA to output the hardware generated statistics.">StatsOutputEnable</a> </dd></dl>

</div>
</div>
<a id="a819566d8ac8ec8f7dbe66d3d6532d3fc" name="a819566d8ac8ec8f7dbe66d3d6532d3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819566d8ac8ec8f7dbe66d3d6532d3fc">&#9670;&#160;</a></span>CnnEnableInputTensor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::CnnEnableInputTensor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boolean to control if the IPA returns the input tensor used by the CNN to generate the output tensors via the CnnInputTensor control. Because the input tensor may be relatively large, for efficiency reason avoid enabling input tensor output unless required for debugging purposes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a9f0b28aa51951207964dfd51841b30d6" title="This control returns a span of uint8_t pixel values that represent the input tensor for a Convolution...">CnnInputTensor</a> </dd></dl>

</div>
</div>
<a id="a9f0b28aa51951207964dfd51841b30d6" name="a9f0b28aa51951207964dfd51841b30d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0b28aa51951207964dfd51841b30d6">&#9670;&#160;</a></span>CnnInputTensor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::CnnInputTensor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This control returns a span of uint8_t pixel values that represent the input tensor for a Convolutional Neural Network (CNN). The size and format of this array of values is entirely dependent on the neural network used, and further post-processing (e.g. pixel normalisations) may need to be performed at the application level to generate the final input image. </p>
<p>The structure of the span is described by the CnnInputTensorInfo control.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#aa99a16630bd42167d9d91c418911ab1e" title="This control returns the structure of the CnnInputTensor. This structure takes the following form:">CnnInputTensorInfo</a> </dd></dl>

</div>
</div>
<a id="aa99a16630bd42167d9d91c418911ab1e" name="aa99a16630bd42167d9d91c418911ab1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99a16630bd42167d9d91c418911ab1e">&#9670;&#160;</a></span>CnnInputTensorInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::CnnInputTensorInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This control returns the structure of the CnnInputTensor. This structure takes the following form: </p>
<p>constexpr unsigned int NetworkNameLen = 64;</p>
<p>struct CnnInputTensorInfo { char networkName[NetworkNameLen]; uint32_t width; uint32_t height; uint32_t numChannels; };</p>
<p>where</p>
<p>networkName is the name of the CNN used, width and height are the input tensor image width and height in pixels, numChannels is the number of channels in the input tensor image.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a9f0b28aa51951207964dfd51841b30d6" title="This control returns a span of uint8_t pixel values that represent the input tensor for a Convolution...">CnnInputTensor</a> </dd></dl>

</div>
</div>
<a id="a46ff2a4ff6a832d6e6a669e4ef3d75ce" name="a46ff2a4ff6a832d6e6a669e4ef3d75ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ff2a4ff6a832d6e6a669e4ef3d75ce">&#9670;&#160;</a></span>CnnOutputTensor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::CnnOutputTensor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This control returns a span of floating point values that represent the output tensors from a Convolutional Neural Network (CNN). The size and format of this array of values is entirely dependent on the neural network used, and further post-processing may need to be performed at the application level to generate the final desired output. This control is agnostic of the hardware or software used to generate the output tensors. </p>
<p>The structure of the span is described by the CnnOutputTensorInfo control.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ad3fb72d9f9a8b9641fa1c82ba65824f3" title="This control returns the structure of the CnnOutputTensor. This structure takes the following form:">CnnOutputTensorInfo</a> </dd></dl>

</div>
</div>
<a id="ad3fb72d9f9a8b9641fa1c82ba65824f3" name="ad3fb72d9f9a8b9641fa1c82ba65824f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fb72d9f9a8b9641fa1c82ba65824f3">&#9670;&#160;</a></span>CnnOutputTensorInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::CnnOutputTensorInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This control returns the structure of the CnnOutputTensor. This structure takes the following form: </p>
<p>constexpr unsigned int NetworkNameLen = 64; constexpr unsigned int MaxNumTensors = 8; constexpr unsigned int MaxNumDimensions = 8;</p>
<p>struct CnnOutputTensorInfo { char networkName[NetworkNameLen]; uint32_t numTensors; OutputTensorInfo info[MaxNumTensors]; };</p>
<p>with</p>
<p>struct OutputTensorInfo { uint32_t tensorDataNum; uint32_t numDimensions; uint16_t size[MaxNumDimensions]; };</p>
<p>networkName is the name of the CNN used, numTensors is the number of output tensors returned, tensorDataNum gives the number of elements in each output tensor, numDimensions gives the dimensionality of each output tensor, size gives the size of each dimension in each output tensor.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a46ff2a4ff6a832d6e6a669e4ef3d75ce" title="This control returns a span of floating point values that represent the output tensors from a Convolu...">CnnOutputTensor</a> </dd></dl>

</div>
</div>
<a id="a60f44d02badac06e27db57838ba53dc7" name="a60f44d02badac06e27db57838ba53dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f44d02badac06e27db57838ba53dc7">&#9670;&#160;</a></span>PispStatsOutput</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::PispStatsOutput</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Span of the PiSP Frontend ISP generated statistics for the current frame. This is sent in the <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request.">Request</a> metadata if the StatsOutputEnable is set to true. The statistics struct definition can be found in <a href="https://github.com/raspberrypi/libpisp/blob/main/src/libpisp/frontend/pisp_statistics.h">https://github.com/raspberrypi/libpisp/blob/main/src/libpisp/frontend/pisp_statistics.h</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ac020d0d9da4ee8af51c76dff0034814b" title="Toggles the Raspberry Pi IPA to output the hardware generated statistics.">StatsOutputEnable</a> </dd></dl>

</div>
</div>
<a id="ada6a6067d2d7e039d27c8bb447723099" name="ada6a6067d2d7e039d27c8bb447723099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6a6067d2d7e039d27c8bb447723099">&#9670;&#160;</a></span>ScalerCrops</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::ScalerCrops</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An array of rectangles, where each singular value has identical functionality to the ScalerCrop control. This control allows the Raspberry Pi pipeline handler to control individual scaler crops per output stream. </p>
<p>The order of rectangles passed into the control must match the order of streams configured by the application. The pipeline handler will only configure crop retangles up-to the number of output streams configured. All subsequent rectangles passed into this control are ignored by the pipeline handler.</p>
<p>If both <a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ada6a6067d2d7e039d27c8bb447723099" title="An array of rectangles, where each singular value has identical functionality to the ScalerCrop contr...">rpi::ScalerCrops</a> and ScalerCrop controls are present in a <a class="el" href="classlibcamera_1_1ControlList.html" title="Associate a list of ControlId with their values for an object.">ControlList</a>, the latter is discarded, and crops are obtained from this control.</p>
<p>Note that using different crop rectangles for each output stream with this control is only applicable on the Pi5/PiSP platform. This control should also be considered temporary/draft and will be replaced with official libcamera API support for per-stream controls in the future.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls.html#a854f9e84af827f57ada03fcc12090c56" title="Sets the image portion that will be scaled to form the whole of the final output image.">ScalerCrop</a> </dd></dl>

</div>
</div>
<a id="ac020d0d9da4ee8af51c76dff0034814b" name="ac020d0d9da4ee8af51c76dff0034814b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac020d0d9da4ee8af51c76dff0034814b">&#9670;&#160;</a></span>StatsOutputEnable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::StatsOutputEnable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggles the Raspberry Pi IPA to output the hardware generated statistics. </p>
<p>When this control is set to true, the IPA outputs a binary dump of the hardware generated statistics through the <a class="el" href="classlibcamera_1_1Request.html" title="A frame capture request.">Request</a> metadata in the Bcm2835StatsOutput control.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#abd959115e9cab5156a7d38879d89c45e" title="Span of the BCM2835 ISP generated statistics for the current frame.">Bcm2835StatsOutput</a> </dd></dl>

</div>
</div>
<a id="ab45ec3457f3ce0d0d705520abec654ce" name="ab45ec3457f3ce0d0d705520abec654ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45ec3457f3ce0d0d705520abec654ce">&#9670;&#160;</a></span>SyncFrames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::SyncFrames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of frames the server should wait, after enabling SyncModeServer, before signalling (via the SyncReady control) that frames should be used. This therefore determines the "ready time" for all synchronised cameras. </p>
<p>This control value should be set only for the device that is to act as the server, before or at the same moment at which SyncModeServer is enabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a6a9df2cf6632619ea60bbb2c4eb08163" title="Enable or disable camera synchronisation (&quot;sync&quot;) mode.">SyncMode</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a15fe9e06097330ea2ef10034cc796662" title="When using the camera synchronisation algorithm, the server broadcasts timing information to the clie...">SyncReady</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#afd88e038a84731276803b902314793d0" title="This reports the amount of time, in microseconds, until the &quot;ready time&quot;, at which the server and cli...">SyncTimer</a> </dd></dl>

</div>
</div>
<a id="a6a9df2cf6632619ea60bbb2c4eb08163" name="a6a9df2cf6632619ea60bbb2c4eb08163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9df2cf6632619ea60bbb2c4eb08163">&#9670;&#160;</a></span>SyncMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::SyncMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable camera synchronisation ("sync") mode. </p>
<p>When sync mode is enabled, a camera will synchronise frames temporally with other cameras, either attached to the same device or a different one. There should be one "server" device, which broadcasts timing information to one or more "clients". Communication is one-way, from server to clients only, and it is only clients that adjust their frame timings to match the server.</p>
<p>Sync mode requires all cameras to be running at (as far as possible) the same fixed framerate. Clients may continue to make adjustments to keep their cameras synchronised with the server for the duration of the session, though any updates after the initial ones should remain small.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a15fe9e06097330ea2ef10034cc796662" title="When using the camera synchronisation algorithm, the server broadcasts timing information to the clie...">SyncReady</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#afd88e038a84731276803b902314793d0" title="This reports the amount of time, in microseconds, until the &quot;ready time&quot;, at which the server and cli...">SyncTimer</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ab45ec3457f3ce0d0d705520abec654ce" title="The number of frames the server should wait, after enabling SyncModeServer, before signalling (via th...">SyncFrames</a> </dd></dl>

</div>
</div>
<a id="a15fe9e06097330ea2ef10034cc796662" name="a15fe9e06097330ea2ef10034cc796662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fe9e06097330ea2ef10034cc796662">&#9670;&#160;</a></span>SyncReady</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::SyncReady</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When using the camera synchronisation algorithm, the server broadcasts timing information to the clients. This also includes the time (some number of frames in the future, called the "ready time") at which the server will signal its controlling application, using this control, to start using the image frames. </p>
<p>The client receives the "ready time" from the server, and will signal its application to start using the frames at this same moment.</p>
<p>While this control value is false, applications (on both client and server) should continue to wait, and not use the frames.</p>
<p>Once this value becomes true, it means that this is the first frame where the server and its clients have agreed that they will both be synchronised and that applications should begin consuming frames. Thereafter, this control will continue to signal the value true for the rest of the session.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a6a9df2cf6632619ea60bbb2c4eb08163" title="Enable or disable camera synchronisation (&quot;sync&quot;) mode.">SyncMode</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#afd88e038a84731276803b902314793d0" title="This reports the amount of time, in microseconds, until the &quot;ready time&quot;, at which the server and cli...">SyncTimer</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ab45ec3457f3ce0d0d705520abec654ce" title="The number of frames the server should wait, after enabling SyncModeServer, before signalling (via th...">SyncFrames</a> </dd></dl>

</div>
</div>
<a id="afd88e038a84731276803b902314793d0" name="afd88e038a84731276803b902314793d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd88e038a84731276803b902314793d0">&#9670;&#160;</a></span>SyncTimer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libcamera::controls::rpi::SyncTimer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This reports the amount of time, in microseconds, until the "ready
time", at which the server and client will signal their controlling applications that the frames are now synchronised and should be used. The value may be refined slightly over time, becoming more precise as the "ready time" approaches. </p>
<p>Servers always report this value, whereas clients will omit this control until they have received a message from the server that enables them to calculate it.</p>
<p>Normally the value will start positive (the "ready time" is in the future), and decrease towards zero, before becoming negative (the "ready
time" has elapsed). So there should be just one frame where the timer value is, or is very close to, zero - the one for which the SyncReady control becomes true. At this moment, the value indicates how closely synchronised the client believes it is with the server.</p>
<p>But note that if frames are being dropped, then the "near zero" valued frame, or indeed any other, could be skipped. In these cases the timer value allows an application to deduce that this has happened.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a6a9df2cf6632619ea60bbb2c4eb08163" title="Enable or disable camera synchronisation (&quot;sync&quot;) mode.">SyncMode</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#a15fe9e06097330ea2ef10034cc796662" title="When using the camera synchronisation algorithm, the server broadcasts timing information to the clie...">SyncReady</a> </dd>
<dd>
<a class="el" href="namespacelibcamera_1_1controls_1_1rpi.html#ab45ec3457f3ce0d0d705520abec654ce" title="The number of frames the server should wait, after enabling SyncModeServer, before signalling (via th...">SyncFrames</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
